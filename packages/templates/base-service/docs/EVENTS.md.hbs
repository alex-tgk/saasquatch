# Event System Documentation

This document describes the event system used by {{service.name}} for asynchronous communication via NATS.

## Overview

The event system enables distributed event-driven architecture by publishing domain events to NATS. Other services can subscribe to these events to:

- React to user lifecycle events (created, updated, deleted)
- Handle tenant provisioning and setup
- Send notifications and emails
- Maintain audit logs and analytics
- Trigger business workflows across services
- Keep data synchronized across microservices

## Event Publishing

Events are published using a **fire-and-forget** pattern. This means:

- Events are published asynchronously
- Event failures are logged but don't break auth flows
- Auth operations succeed even if event publishing fails
- Events use NATS JetStream for persistence and replay

## NATS Configuration

### JetStream Stream

**Stream Name**: `auth-events`

**Configuration**:
- **Subjects**: `auth.user.*`
- **Retention**: Limits-based (oldest messages deleted when limits reached)
- **Max Messages**: 100,000
- **Max Size**: 100 MB
- **Max Age**: 7 days
- **Storage**: File (persisted to disk)
- **Discard Policy**: Old (discard oldest when full)

## Event Architecture

### Publisher Plugin

The `nats-publisher` plugin provides:
- Connection management with automatic reconnection
- Event publishing with exponential backoff retry (max 3 attempts)
- Dead-letter queue (DLQ) for failed events
- Event ID generation (UUID v4)
- Type-safe event interfaces

### Subscriber Plugin

The `nats-subscriber` plugin provides:
- Queue group subscriptions for load balancing
- Event handlers registry
- Automatic message acknowledgment
- Error handling with negative acknowledgment for retries
- DLQ monitoring

### Retry Logic

Failed events are retried with exponential backoff:
1. First attempt: immediate
2. Second attempt: after 2 seconds
3. Third attempt: after 4 seconds
4. After 3 failures: event sent to DLQ

### Dead-Letter Queue

Events that fail after 3 retry attempts are sent to the `events_dlq` subject with:
- Original event data
- Error message
- Number of attempts
- DLQ timestamp

## Event Types

### Core Events

### 1. User Created

**Subject**: `user_created`

**Published When**: A new user is successfully created in the system

**Payload**:
```typescript
{
  id: string,            // Unique event ID (UUID)
  type: 'user.created',
  timestamp: string,     // ISO 8601 timestamp
  tenantId: string,      // Tenant context
  version: '1.0.0',
  data: {
    userId: string,      // UUID of the created user
    email: string,       // User's email address
    name: string,        // User's full name
    tenantId: string     // Tenant ID
  }
}
```

**Example**:
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "type": "user.created",
  "timestamp": "2024-01-01T12:00:00.000Z",
  "tenantId": "acme-corp",
  "version": "1.0.0",
  "data": {
    "userId": "123e4567-e89b-12d3-a456-426614174000",
    "email": "john.doe@example.com",
    "name": "John Doe",
    "tenantId": "acme-corp"
  }
}
```

**Use Cases**:
- Send welcome email
- Create user profile in other services
- Initialize user preferences
- Trigger onboarding workflow
- Add to analytics platform

---

### 2. User Updated

**Subject**: `user_updated`

**Published When**: A user's information is updated

**Payload**:
```typescript
{
  id: string,
  type: 'user.updated',
  timestamp: string,
  tenantId: string,
  version: '1.0.0',
  data: {
    userId: string,
    updates: Record<string, any>,  // Changed fields
    tenantId: string
  }
}
```

**Use Cases**:
- Sync user data across services
- Update caches
- Audit trail
- Trigger notifications if profile changes

---

### 3. User Deleted

**Subject**: `user_deleted`

**Published When**: A user is deleted from the system

**Payload**:
```typescript
{
  id: string,
  type: 'user.deleted',
  timestamp: string,
  tenantId: string,
  version: '1.0.0',
  data: {
    userId: string,
    tenantId: string
  }
}
```

**Use Cases**:
- Remove user data from other services
- Clear caches
- Compliance (GDPR right to deletion)
- Audit logging

---

### 4. Tenant Created

**Subject**: `tenant_created`

**Published When**: A new tenant is created in the system

**Payload**:
```typescript
{
  id: string,
  type: 'tenant.created',
  timestamp: string,
  tenantId: string,
  version: '1.0.0',
  data: {
    tenantId: string,
    name: string,
    email: string
  }
}
```

**Use Cases**:
- Create tenant-specific database schemas
- Initialize tenant configuration
- Send onboarding emails
- Setup tenant resources

---

### 5. Tenant Ready

**Subject**: `tenant_ready`

**Published When**: A tenant's infrastructure is fully provisioned and ready

**Payload**:
```typescript
{
  id: string,
  type: 'tenant.ready',
  timestamp: string,
  tenantId: string,
  version: '1.0.0',
  data: {
    tenantId: string,
    status: 'ready'
  }
}
```

**Use Cases**:
- Enable tenant access
- Notify administrators
- Trigger post-provisioning workflows

---

### 2. User Logged In (Authentication Events)

**Subject**: `auth.user.logged_in`

**Published When**: A user successfully logs in with valid credentials

**Payload**:
```typescript
{
  subject: 'auth.user.logged_in',
  data: {
    userId: string,        // UUID of the logged-in user
    email: string,         // User's email address
    timestamp: string,     // ISO 8601 timestamp of login
    ip?: string,           // Optional: IP address (from X-Forwarded-For or request.ip)
    userAgent?: string     // Optional: User agent string
  },
  metadata: {
    service: 'auth-service',
    version: '1.0.0',
    environment: 'production'
  }
}
```

**Example**:
```json
{
  "subject": "auth.user.logged_in",
  "data": {
    "userId": "123e4567-e89b-12d3-a456-426614174000",
    "email": "john.doe@example.com",
    "timestamp": "2024-01-01T12:30:00.000Z",
    "ip": "192.168.1.100",
    "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)"
  },
  "metadata": {
    "service": "auth-service",
    "version": "1.0.0",
    "environment": "production"
  }
}
```

**Use Cases**:
- Track login activity
- Detect suspicious login patterns
- Update last active timestamp
- Send security notifications
- Maintain session across services

---

### 3. User Logged Out

**Subject**: `auth.user.logged_out`

**Published When**: A user successfully logs out (token blacklisted)

**Payload**:
```typescript
{
  subject: 'auth.user.logged_out',
  data: {
    userId: string,        // UUID of the logged-out user
    timestamp: string      // ISO 8601 timestamp of logout
  },
  metadata: {
    service: 'auth-service',
    version: '1.0.0',
    environment: 'production'
  }
}
```

**Example**:
```json
{
  "subject": "auth.user.logged_out",
  "data": {
    "userId": "123e4567-e89b-12d3-a456-426614174000",
    "timestamp": "2024-01-01T13:00:00.000Z"
  },
  "metadata": {
    "service": "auth-service",
    "version": "1.0.0",
    "environment": "production"
  }
}
```

**Use Cases**:
- Invalidate sessions in other services
- Clear user caches
- Update session status
- Audit logging

---

### 4. User Token Refreshed

**Subject**: `auth.user.token_refreshed`

**Published When**: A user refreshes their access token using a refresh token

**Payload**:
```typescript
{
  subject: 'auth.user.token_refreshed',
  data: {
    userId: string,        // UUID of the user refreshing token
    timestamp: string      // ISO 8601 timestamp of token refresh
  },
  metadata: {
    service: 'auth-service',
    version: '1.0.0',
    environment: 'production'
  }
}
```

**Example**:
```json
{
  "subject": "auth.user.token_refreshed",
  "data": {
    "userId": "123e4567-e89b-12d3-a456-426614174000",
    "timestamp": "2024-01-01T12:45:00.000Z"
  },
  "metadata": {
    "service": "auth-service",
    "version": "1.0.0",
    "environment": "production"
  }
}
```

**Use Cases**:
- Track active sessions
- Monitor token refresh patterns
- Detect abnormal refresh rates
- Security auditing

---

## Publishing Events

### From Within a Service

```typescript
// Publishing events is simple with the nats-publisher plugin
await fastify.publishEvent({
  id: fastify.generateEventId(),
  type: 'user.created',
  timestamp: new Date().toISOString(),
  tenantId: 'acme-corp',
  version: '1.0.0',
  data: {
    userId: user.id,
    email: user.email,
    name: user.name,
    tenantId: 'acme-corp'
  }
});
```

### Event Publishing Features

- **Automatic Retry**: Failed publishes are retried with exponential backoff
- **Dead-Letter Queue**: Events that fail after 3 retries go to DLQ
- **Type Safety**: TypeScript interfaces ensure correct event structure
- **Logging**: All publish attempts and results are logged

## Subscribing to Events

### Using NATS CLI

```bash
# Subscribe to all events
nats sub "user_*"
nats sub "tenant_*"

# Subscribe to specific event
nats sub "user_created"
nats sub "tenant_created"

# Monitor dead-letter queue
nats sub "events_dlq"
```

### Creating Event Handlers

Event handlers are registered in the `nats-subscriber` plugin:

```typescript
// Add handler in nats-subscriber.ts
handlers.set('user_created', async (event, fastify) => {
  if (event.type !== 'user.created') return;

  // Process the event
  fastify.log.info({ userId: event.data.userId }, 'Processing user created');

  // Your business logic here
  await sendWelcomeEmail(event.data.email);
});
```

### Subscriber Features

- **Queue Groups**: Multiple instances share load automatically
- **Acknowledgment**: Messages are acked after successful processing
- **Error Handling**: Failed messages are negatively acknowledged for retry
- **DLQ Monitoring**: Failed events are logged from the dead-letter queue

## Error Handling

Event publishing uses graceful error handling:

1. **Success**: Event published to NATS, logged with `info` level
2. **Failure**: Error logged with `error` level, auth operation continues
3. **No Impact**: Event failures never break auth flows

Example log output:

**Success**:
```json
{
  "level": "info",
  "event": "auth.user.registered",
  "userId": "123e4567-e89b-12d3-a456-426614174000",
  "timestamp": "2024-01-01T12:00:00.000Z",
  "msg": "Auth event published successfully"
}
```

**Failure**:
```json
{
  "level": "error",
  "event": "auth.user.registered",
  "error": "Connection timeout",
  "payload": { "userId": "...", "email": "..." },
  "msg": "Failed to publish auth event"
}
```

## Best Practices

### For Publishers (Auth Service)

1. **Keep events simple** - Include only essential data
2. **Use timestamps** - Always include ISO 8601 timestamps
3. **Log failures** - Track event publishing issues
4. **Don't block** - Use fire-and-forget pattern
5. **Include metadata** - Service name, version, environment

### For Subscribers (Consumer Services)

1. **Use durable consumers** - Ensure message persistence
2. **Acknowledge messages** - Mark messages as processed
3. **Handle duplicates** - Events may be delivered multiple times
4. **Use idempotent processing** - Same event processed twice should be safe
5. **Set up error handling** - Dead letter queues for failed processing

## Security Considerations

1. **Sensitive Data**: Events intentionally exclude sensitive data like passwords or tokens
2. **PII**: Email and name are included but should be handled per privacy policies
3. **Access Control**: Configure NATS ACLs to restrict event access
4. **Encryption**: Use TLS for NATS connections in production

## Monitoring

### Key Metrics

Monitor these metrics for healthy event publishing:

- Event publish success rate
- Event publish latency
- NATS connection health
- JetStream stream size
- Consumer lag
- Dead letter queue size

### NATS CLI Monitoring

```bash
# Check stream status
nats stream info auth-events

# Check consumer status
nats consumer info auth-events my-service-consumer

# Monitor messages
nats stream view auth-events
```

## Troubleshooting

### Events not publishing

1. Check NATS connection: `NATS connected successfully` in logs
2. Check JetStream enabled: `nats server info`
3. Check stream exists: `nats stream ls`
4. Check auth route logs for publish errors

### Events not received

1. Check consumer configuration
2. Verify subject subscription pattern
3. Check consumer acknowledgments
4. Review consumer lag

### High event volume

1. Increase stream limits (max_msgs, max_bytes)
2. Decrease retention period (max_age)
3. Add more consumers for parallel processing
4. Archive old events

## Related Documentation

- [NATS JetStream Documentation](https://docs.nats.io/nats-concepts/jetstream)
- [Auth Routes API](/docs/api/auth.md)
- [Service Architecture](/docs/architecture.md)
