import { describe, it, expect, beforeAll, afterAll, beforeEach } from '@jest/globals';
import { buildApp } from '../../src/app.js';
import { FastifyInstance } from 'fastify';
import Knex from 'knex';

describe('Tenant Isolation', () => {
  let app: FastifyInstance;
  let db: Knex.Knex;
  let tenant1Token: string;
  let tenant2Token: string;
  const tenant1Id = 'test-tenant-1';
  const tenant2Id = 'test-tenant-2';

  beforeAll(async () => {
    // Setup database
    db = Knex({
      client: 'pg',
      connection: {
        host: process.env.DB_HOST || 'localhost',
        port: parseInt(process.env.DB_PORT || '5432'),
        user: process.env.DB_USER || 'postgres',
        password: process.env.DB_PASSWORD || 'postgres',
        database: process.env.DB_NAME || 'test_db'
      }
    });

    // Create tenant schemas
    await db.raw(`SELECT create_tenant_schema('${tenant1Id}')`);
    await db.raw(`SELECT create_tenant_schema('${tenant2Id}')`);

    // Build app
    app = await buildApp();
    await app.ready();

    // Generate JWT tokens for each tenant
    tenant1Token = app.jwt.sign({
      userId: 'user-1',
      email: 'user1@tenant1.com',
      tenantId: tenant1Id
    });

    tenant2Token = app.jwt.sign({
      userId: 'user-2',
      email: 'user2@tenant2.com',
      tenantId: tenant2Id
    });
  });

  afterAll(async () => {
    // Clean up tenant schemas
    await db.raw(`DROP SCHEMA IF EXISTS tenant_${tenant1Id} CASCADE`);
    await db.raw(`DROP SCHEMA IF EXISTS tenant_${tenant2Id} CASCADE`);
    await db.destroy();
    await app.close();
  });

  beforeEach(async () => {
    // Clean tenant data before each test
    await db.raw(`TRUNCATE TABLE tenant_${tenant1Id}.users CASCADE`);
    await db.raw(`TRUNCATE TABLE tenant_${tenant2Id}.users CASCADE`);
  });

  describe('Data Isolation', () => {
    it('should isolate user data between tenants', async () => {
      // Create user in tenant 1
      const user1Response = await app.inject({
        method: 'POST',
        url: '/users',
        headers: {
          authorization: `Bearer ${tenant1Token}`
        },
        payload: {
          email: 'user@tenant1.com',
          name: 'Tenant 1 User'
        }
      });
      expect(user1Response.statusCode).toBe(201);
      const user1 = JSON.parse(user1Response.payload);

      // Create user in tenant 2
      const user2Response = await app.inject({
        method: 'POST',
        url: '/users',
        headers: {
          authorization: `Bearer ${tenant2Token}`
        },
        payload: {
          email: 'user@tenant2.com',
          name: 'Tenant 2 User'
        }
      });
      expect(user2Response.statusCode).toBe(201);
      const user2 = JSON.parse(user2Response.payload);

      // Tenant 1 should only see their user
      const tenant1UsersResponse = await app.inject({
        method: 'GET',
        url: '/users',
        headers: {
          authorization: `Bearer ${tenant1Token}`
        }
      });
      expect(tenant1UsersResponse.statusCode).toBe(200);
      const tenant1Users = JSON.parse(tenant1UsersResponse.payload);
      expect(tenant1Users).toHaveLength(1);
      expect(tenant1Users[0].email).toBe('user@tenant1.com');

      // Tenant 2 should only see their user
      const tenant2UsersResponse = await app.inject({
        method: 'GET',
        url: '/users',
        headers: {
          authorization: `Bearer ${tenant2Token}`
        }
      });
      expect(tenant2UsersResponse.statusCode).toBe(200);
      const tenant2Users = JSON.parse(tenant2UsersResponse.payload);
      expect(tenant2Users).toHaveLength(1);
      expect(tenant2Users[0].email).toBe('user@tenant2.com');
    });

    it('should prevent cross-tenant access to user data', async () => {
      // Create user in tenant 1
      const user1Response = await app.inject({
        method: 'POST',
        url: '/users',
        headers: {
          authorization: `Bearer ${tenant1Token}`
        },
        payload: {
          email: 'user@tenant1.com',
          name: 'Tenant 1 User'
        }
      });
      const user1 = JSON.parse(user1Response.payload);

      // Try to access tenant 1's user with tenant 2's token
      const crossTenantResponse = await app.inject({
        method: 'GET',
        url: `/users/${user1.id}`,
        headers: {
          authorization: `Bearer ${tenant2Token}`
        }
      });

      // Should get 404 because user doesn't exist in tenant 2's schema
      expect(crossTenantResponse.statusCode).toBe(404);
    });

    it('should prevent cross-tenant updates', async () => {
      // Create user in tenant 1
      const user1Response = await app.inject({
        method: 'POST',
        url: '/users',
        headers: {
          authorization: `Bearer ${tenant1Token}`
        },
        payload: {
          email: 'user@tenant1.com',
          name: 'Original Name'
        }
      });
      const user1 = JSON.parse(user1Response.payload);

      // Try to update tenant 1's user with tenant 2's token
      const updateResponse = await app.inject({
        method: 'PUT',
        url: `/users/${user1.id}`,
        headers: {
          authorization: `Bearer ${tenant2Token}`
        },
        payload: {
          name: 'Hacked Name'
        }
      });

      expect(updateResponse.statusCode).toBe(404);

      // Verify original user unchanged
      const verifyResponse = await app.inject({
        method: 'GET',
        url: `/users/${user1.id}`,
        headers: {
          authorization: `Bearer ${tenant1Token}`
        }
      });
      const verified = JSON.parse(verifyResponse.payload);
      expect(verified.name).toBe('Original Name');
    });

    it('should prevent cross-tenant deletes', async () => {
      // Create user in tenant 1
      const user1Response = await app.inject({
        method: 'POST',
        url: '/users',
        headers: {
          authorization: `Bearer ${tenant1Token}`
        },
        payload: {
          email: 'user@tenant1.com',
          name: 'Tenant 1 User'
        }
      });
      const user1 = JSON.parse(user1Response.payload);

      // Try to delete tenant 1's user with tenant 2's token
      const deleteResponse = await app.inject({
        method: 'DELETE',
        url: `/users/${user1.id}`,
        headers: {
          authorization: `Bearer ${tenant2Token}`
        }
      });

      expect(deleteResponse.statusCode).toBe(404);

      // Verify user still exists
      const verifyResponse = await app.inject({
        method: 'GET',
        url: `/users/${user1.id}`,
        headers: {
          authorization: `Bearer ${tenant1Token}`
        }
      });
      expect(verifyResponse.statusCode).toBe(200);
    });
  });

  describe('Tenant Context Validation', () => {
    it('should require tenant context for protected endpoints', async () => {
      // Create token without tenantId
      const invalidToken = app.jwt.sign({
        userId: 'user-1',
        email: 'user@example.com'
      });

      const response = await app.inject({
        method: 'GET',
        url: '/users',
        headers: {
          authorization: `Bearer ${invalidToken}`
        }
      });

      expect(response.statusCode).toBe(400);
      const body = JSON.parse(response.payload);
      expect(body.error).toContain('Tenant context required');
    });

    it('should allow public endpoints without tenant context', async () => {
      const healthResponse = await app.inject({
        method: 'GET',
        url: '/health'
      });
      expect(healthResponse.statusCode).toBe(200);

      const docsResponse = await app.inject({
        method: 'GET',
        url: '/docs'
      });
      expect(docsResponse.statusCode).toBe(200);
    });
  });
});
