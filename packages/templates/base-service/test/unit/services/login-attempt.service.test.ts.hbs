{{#if service.features.cache}}import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import { FastifyInstance } from 'fastify';
import { Redis } from 'ioredis';
import { LoginAttemptService } from '../../../src/services/login-attempt.service.js';
import { buildApp } from '../../../src/app.js';

describe('LoginAttemptService', () => {
  let app: FastifyInstance;
  let loginAttemptService: LoginAttemptService;
  let redis: Redis;
  const testEmail = 'test@example.com';
  const testIp = '192.168.1.1';

  beforeEach(async () => {
    // Build app with test configuration
    app = await buildApp({
      logger: false,
    });

    await app.ready();
    redis = app.redis;
    loginAttemptService = new LoginAttemptService(app, redis);

    // Clean up any existing test data
    await redis.del(`login:attempts:${testEmail}`);
    await redis.del(`login:lockout:${testEmail}`);
  });

  afterEach(async () => {
    // Clean up test data
    await redis.del(`login:attempts:${testEmail}`);
    await redis.del(`login:lockout:${testEmail}`);
    await app.close();
  });

  describe('recordAttempt', () => {
    it('should record a failed login attempt', async () => {
      await loginAttemptService.recordAttempt(testEmail, false, testIp);

      const attempts = await loginAttemptService.getRecentAttempts(testEmail);
      expect(attempts).toHaveLength(1);
      expect(attempts[0].email).toBe(testEmail);
      expect(attempts[0].success).toBe(false);
      expect(attempts[0].ip).toBe(testIp);
    });

    it('should record multiple failed login attempts', async () => {
      await loginAttemptService.recordAttempt(testEmail, false, testIp);
      await loginAttemptService.recordAttempt(testEmail, false, testIp);
      await loginAttemptService.recordAttempt(testEmail, false, testIp);

      const attempts = await loginAttemptService.getRecentAttempts(testEmail);
      expect(attempts).toHaveLength(3);
    });

    it('should clear attempts on successful login', async () => {
      // Record some failed attempts
      await loginAttemptService.recordAttempt(testEmail, false, testIp);
      await loginAttemptService.recordAttempt(testEmail, false, testIp);

      let attempts = await loginAttemptService.getRecentAttempts(testEmail);
      expect(attempts).toHaveLength(2);

      // Record successful login
      await loginAttemptService.recordAttempt(testEmail, true, testIp);

      // Attempts should be cleared
      attempts = await loginAttemptService.getRecentAttempts(testEmail);
      expect(attempts).toHaveLength(0);
    });

    it('should set TTL on failed attempts', async () => {
      await loginAttemptService.recordAttempt(testEmail, false, testIp);

      const ttl = await redis.ttl(`login:attempts:${testEmail}`);
      expect(ttl).toBeGreaterThan(0);
      expect(ttl).toBeLessThanOrEqual(15 * 60); // 15 minutes
    });
  });

  describe('lockAccount', () => {
    it('should lock account after 5 failed attempts', async () => {
      // Record 5 failed attempts
      for (let i = 0; i < 5; i++) {
        await loginAttemptService.recordAttempt(testEmail, false, testIp);
      }

      const isLocked = await loginAttemptService.isAccountLocked(testEmail);
      expect(isLocked).toBe(true);
    });

    it('should set lockout TTL to 30 minutes', async () => {
      await loginAttemptService.lockAccount(testEmail);

      const ttl = await redis.ttl(`login:lockout:${testEmail}`);
      expect(ttl).toBeGreaterThan(0);
      expect(ttl).toBeLessThanOrEqual(30 * 60); // 30 minutes
    });

    it('should unlock account after successful login', async () => {
      // Lock the account
      await loginAttemptService.lockAccount(testEmail);
      expect(await loginAttemptService.isAccountLocked(testEmail)).toBe(true);

      // Successful login should unlock
      await loginAttemptService.recordAttempt(testEmail, true, testIp);
      expect(await loginAttemptService.isAccountLocked(testEmail)).toBe(false);
    });
  });

  describe('getRemainingAttempts', () => {
    it('should return 5 attempts for new user', async () => {
      const remaining = await loginAttemptService.getRemainingAttempts(testEmail);
      expect(remaining).toBe(5);
    });

    it('should decrease remaining attempts after each failure', async () => {
      await loginAttemptService.recordAttempt(testEmail, false, testIp);
      let remaining = await loginAttemptService.getRemainingAttempts(testEmail);
      expect(remaining).toBe(4);

      await loginAttemptService.recordAttempt(testEmail, false, testIp);
      remaining = await loginAttemptService.getRemainingAttempts(testEmail);
      expect(remaining).toBe(3);

      await loginAttemptService.recordAttempt(testEmail, false, testIp);
      remaining = await loginAttemptService.getRemainingAttempts(testEmail);
      expect(remaining).toBe(2);
    });

    it('should return 0 when account is locked', async () => {
      // Record 5 failed attempts to lock account
      for (let i = 0; i < 5; i++) {
        await loginAttemptService.recordAttempt(testEmail, false, testIp);
      }

      const remaining = await loginAttemptService.getRemainingAttempts(testEmail);
      expect(remaining).toBe(0);
    });

    it('should reset to 5 after successful login', async () => {
      // Record some failures
      await loginAttemptService.recordAttempt(testEmail, false, testIp);
      await loginAttemptService.recordAttempt(testEmail, false, testIp);

      let remaining = await loginAttemptService.getRemainingAttempts(testEmail);
      expect(remaining).toBe(3);

      // Successful login
      await loginAttemptService.recordAttempt(testEmail, true, testIp);

      remaining = await loginAttemptService.getRemainingAttempts(testEmail);
      expect(remaining).toBe(5);
    });
  });

  describe('getLockoutTimeRemaining', () => {
    it('should return 0 for unlocked account', async () => {
      const timeRemaining = await loginAttemptService.getLockoutTimeRemaining(testEmail);
      expect(timeRemaining).toBe(0);
    });

    it('should return time remaining for locked account', async () => {
      await loginAttemptService.lockAccount(testEmail);

      const timeRemaining = await loginAttemptService.getLockoutTimeRemaining(testEmail);
      expect(timeRemaining).toBeGreaterThan(0);
      expect(timeRemaining).toBeLessThanOrEqual(30 * 60); // 30 minutes
    });

    it('should decrease over time', async () => {
      await loginAttemptService.lockAccount(testEmail);

      const initialTime = await loginAttemptService.getLockoutTimeRemaining(testEmail);

      // Wait 1 second
      await new Promise(resolve => setTimeout(resolve, 1000));

      const laterTime = await loginAttemptService.getLockoutTimeRemaining(testEmail);
      expect(laterTime).toBeLessThan(initialTime);
    });
  });

  describe('isAccountLocked', () => {
    it('should return false for new user', async () => {
      const isLocked = await loginAttemptService.isAccountLocked(testEmail);
      expect(isLocked).toBe(false);
    });

    it('should return true after account is locked', async () => {
      await loginAttemptService.lockAccount(testEmail);

      const isLocked = await loginAttemptService.isAccountLocked(testEmail);
      expect(isLocked).toBe(true);
    });

    it('should return false after lockout expires (integration test)', async () => {
      // Manually set a very short lockout for testing
      await redis.setex(`login:lockout:${testEmail}`, 1, '1');

      let isLocked = await loginAttemptService.isAccountLocked(testEmail);
      expect(isLocked).toBe(true);

      // Wait for expiry
      await new Promise(resolve => setTimeout(resolve, 1100));

      isLocked = await loginAttemptService.isAccountLocked(testEmail);
      expect(isLocked).toBe(false);
    });
  });

  describe('getRecentAttempts', () => {
    it('should return empty array for new user', async () => {
      const attempts = await loginAttemptService.getRecentAttempts(testEmail);
      expect(attempts).toEqual([]);
    });

    it('should return all recorded attempts in order', async () => {
      await loginAttemptService.recordAttempt(testEmail, false, '192.168.1.1');
      await loginAttemptService.recordAttempt(testEmail, false, '192.168.1.2');
      await loginAttemptService.recordAttempt(testEmail, false, '192.168.1.3');

      const attempts = await loginAttemptService.getRecentAttempts(testEmail);
      expect(attempts).toHaveLength(3);
      expect(attempts[0].ip).toBe('192.168.1.1');
      expect(attempts[1].ip).toBe('192.168.1.2');
      expect(attempts[2].ip).toBe('192.168.1.3');
    });

    it('should correctly parse attempt data', async () => {
      await loginAttemptService.recordAttempt(testEmail, false, testIp);

      const attempts = await loginAttemptService.getRecentAttempts(testEmail);
      expect(attempts[0]).toHaveProperty('email', testEmail);
      expect(attempts[0]).toHaveProperty('success', false);
      expect(attempts[0]).toHaveProperty('ip', testIp);
      expect(attempts[0]).toHaveProperty('timestamp');
    });
  });

  describe('Edge Cases', () => {
    it('should handle attempts without IP address', async () => {
      await loginAttemptService.recordAttempt(testEmail, false);

      const attempts = await loginAttemptService.getRecentAttempts(testEmail);
      expect(attempts).toHaveLength(1);
      expect(attempts[0].ip).toBeUndefined();
    });

    it('should handle multiple users independently', async () => {
      const email1 = 'user1@example.com';
      const email2 = 'user2@example.com';

      await loginAttemptService.recordAttempt(email1, false, testIp);
      await loginAttemptService.recordAttempt(email1, false, testIp);

      await loginAttemptService.recordAttempt(email2, false, testIp);

      const attempts1 = await loginAttemptService.getRemainingAttempts(email1);
      const attempts2 = await loginAttemptService.getRemainingAttempts(email2);

      expect(attempts1).toBe(3);
      expect(attempts2).toBe(4);

      // Clean up
      await redis.del(`login:attempts:${email1}`);
      await redis.del(`login:attempts:${email2}`);
    });

    it('should not interfere with lockout when under threshold', async () => {
      await loginAttemptService.recordAttempt(testEmail, false, testIp);
      await loginAttemptService.recordAttempt(testEmail, false, testIp);
      await loginAttemptService.recordAttempt(testEmail, false, testIp);

      const isLocked = await loginAttemptService.isAccountLocked(testEmail);
      expect(isLocked).toBe(false);
    });
  });
});
{{/if}}