import { describe, it, expect, beforeEach } from '@jest/globals';
import { CircuitBreaker } from '../../src/utils/circuit-breaker.js';

describe('CircuitBreaker', () => {
  let breaker: CircuitBreaker;

  beforeEach(() => {
    breaker = new CircuitBreaker({
      failureThreshold: 3,
      successThreshold: 2,
      timeout: 1000
    });
  });

  describe('CLOSED state', () => {
    it('should start in CLOSED state', () => {
      expect(breaker.getState()).toBe('CLOSED');
    });

    it('should execute function successfully', async () => {
      const result = await breaker.execute(async () => 'success');
      expect(result).toBe('success');
      expect(breaker.getState()).toBe('CLOSED');
    });

    it('should transition to OPEN after threshold failures', async () => {
      const failingFn = async () => { throw new Error('fail'); };

      for (let i = 0; i < 3; i++) {
        try {
          await breaker.execute(failingFn);
        } catch (e) {
          // Expected
        }
      }

      expect(breaker.getState()).toBe('OPEN');
    });
  });

  describe('OPEN state', () => {
    beforeEach(async () => {
      // Trigger failures to open circuit
      const failingFn = async () => { throw new Error('fail'); };
      for (let i = 0; i < 3; i++) {
        try {
          await breaker.execute(failingFn);
        } catch (e) {
          // Expected
        }
      }
    });

    it('should reject requests immediately when OPEN', async () => {
      await expect(breaker.execute(async () => 'success'))
        .rejects.toThrow('Circuit breaker is OPEN');
    });

    it('should transition to HALF_OPEN after timeout', async () => {
      // Wait for timeout
      await new Promise(resolve => setTimeout(resolve, 1100));

      // Next request should attempt (HALF_OPEN)
      await breaker.execute(async () => 'success');
      expect(breaker.getState()).toBe('HALF_OPEN');
    });
  });

  describe('HALF_OPEN state', () => {
    beforeEach(async () => {
      // Open circuit
      const failingFn = async () => { throw new Error('fail'); };
      for (let i = 0; i < 3; i++) {
        try {
          await breaker.execute(failingFn);
        } catch (e) {
          // Expected
        }
      }

      // Wait for timeout to reach HALF_OPEN
      await new Promise(resolve => setTimeout(resolve, 1100));
      await breaker.execute(async () => 'success');
    });

    it('should be in HALF_OPEN state', () => {
      expect(breaker.getState()).toBe('HALF_OPEN');
    });

    it('should close after success threshold', async () => {
      // One more success (total 2) should close circuit
      await breaker.execute(async () => 'success');
      expect(breaker.getState()).toBe('CLOSED');
    });

    it('should reopen on failure', async () => {
      try {
        await breaker.execute(async () => { throw new Error('fail'); });
      } catch (e) {
        // Expected
      }
      expect(breaker.getState()).toBe('OPEN');
    });
  });

  describe('Statistics', () => {
    it('should track request statistics', async () => {
      await breaker.execute(async () => 'success');
      await breaker.execute(async () => 'success');

      try {
        await breaker.execute(async () => { throw new Error('fail'); });
      } catch (e) {
        // Expected
      }

      const stats = breaker.getStats();
      expect(stats.totalRequests).toBe(3);
      expect(stats.successfulRequests).toBe(2);
      expect(stats.failedRequests).toBe(1);
    });
  });

  describe('Reset', () => {
    it('should reset to CLOSED state', async () => {
      // Open circuit
      const failingFn = async () => { throw new Error('fail'); };
      for (let i = 0; i < 3; i++) {
        try {
          await breaker.execute(failingFn);
        } catch (e) {
          // Expected
        }
      }
      expect(breaker.getState()).toBe('OPEN');

      // Reset
      breaker.reset();
      expect(breaker.getState()).toBe('CLOSED');

      const stats = breaker.getStats();
      expect(stats.failures).toBe(0);
      expect(stats.consecutiveFailures).toBe(0);
    });
  });
});
