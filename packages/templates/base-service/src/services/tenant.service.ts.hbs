import { Knex } from 'knex';

export class TenantService {
  constructor(private db: Knex) {}

  /**
   * Create a new tenant schema with all required tables
   */
  async createTenantSchema(tenantId: string): Promise<void> {
    try {
      // Create schema
      await this.db.raw(`CREATE SCHEMA IF NOT EXISTS tenant_${tenantId}`);

      // Create users table in tenant schema
      await this.db.raw(`
        CREATE TABLE IF NOT EXISTS tenant_${tenantId}.users (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          email VARCHAR(255) UNIQUE NOT NULL,
          name VARCHAR(255) NOT NULL,
          avatar_url VARCHAR(500),
          metadata JSONB DEFAULT '{}'::jsonb,
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW()
        )
      `);

      // Create indexes
      await this.db.raw(`
        CREATE INDEX IF NOT EXISTS idx_users_email
        ON tenant_${tenantId}.users(email)
      `);

      await this.db.raw(`
        CREATE INDEX IF NOT EXISTS idx_users_created_at
        ON tenant_${tenantId}.users(created_at DESC)
      `);

      // Create updated_at trigger
      await this.db.raw(`
        CREATE OR REPLACE FUNCTION tenant_${tenantId}.update_updated_at_column()
        RETURNS TRIGGER AS $$
        BEGIN
          NEW.updated_at = NOW();
          RETURN NEW;
        END;
        $$ language 'plpgsql';
      `);

      await this.db.raw(`
        CREATE TRIGGER update_users_updated_at
        BEFORE UPDATE ON tenant_${tenantId}.users
        FOR EACH ROW
        EXECUTE FUNCTION tenant_${tenantId}.update_updated_at_column();
      `);

      (this.db as any).context?.log?.info({ tenantId }, 'Created tenant schema successfully');
    } catch (error: any) {
      (this.db as any).context?.log?.error({ error, tenantId }, 'Failed to create tenant schema');
      throw new Error(`Failed to create tenant schema: ${error.message}`);
    }
  }

  /**
   * Check if tenant schema exists
   */
  async tenantExists(tenantId: string): Promise<boolean> {
    const result = await this.db.raw(`
      SELECT schema_name
      FROM information_schema.schemata
      WHERE schema_name = ?
    `, [`tenant_${tenantId}`]);

    return result.rows.length > 0;
  }

  /**
   * Delete tenant schema and all data (use with caution!)
   */
  async deleteTenantSchema(tenantId: string): Promise<void> {
    try {
      await this.db.raw(`DROP SCHEMA IF EXISTS tenant_${tenantId} CASCADE`);
      (this.db as any).context?.log?.info({ tenantId }, 'Deleted tenant schema');
    } catch (error: any) {
      (this.db as any).context?.log?.error({ error, tenantId }, 'Failed to delete tenant schema');
      throw new Error(`Failed to delete tenant schema: ${error.message}`);
    }
  }

  /**
   * List all tenant schemas
   */
  async listTenants(): Promise<string[]> {
    const result = await this.db.raw(`
      SELECT schema_name
      FROM information_schema.schemata
      WHERE schema_name LIKE 'tenant_%'
    `);

    return result.rows.map((row: any) =>
      row.schema_name.replace('tenant_', '')
    );
  }

  /**
   * Get tenant statistics
   */
  async getTenantStats(tenantId: string): Promise<{
    userCount: number;
    schemaSize: string;
    createdAt: Date | null;
  }> {
    const exists = await this.tenantExists(tenantId);
    if (!exists) {
      throw new Error(`Tenant ${tenantId} does not exist`);
    }

    // Get user count
    const userCountResult = await this.db.raw(`
      SELECT COUNT(*) as count
      FROM tenant_${tenantId}.users
    `);
    const userCount = parseInt(userCountResult.rows[0].count);

    // Get schema size
    const sizeResult = await this.db.raw(`
      SELECT pg_size_pretty(
        pg_total_relation_size(schemaname || '.' || tablename)
      ) as size
      FROM pg_tables
      WHERE schemaname = ?
    `, [`tenant_${tenantId}`]);
    const schemaSize = sizeResult.rows[0]?.size || '0 bytes';

    // Get oldest record timestamp as creation proxy
    const createdResult = await this.db.raw(`
      SELECT MIN(created_at) as created_at
      FROM tenant_${tenantId}.users
    `);
    const createdAt = createdResult.rows[0]?.created_at || null;

    return {
      userCount,
      schemaSize,
      createdAt
    };
  }
}
