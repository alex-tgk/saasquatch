import { FastifyPluginAsync } from 'fastify';

export const healthRoutes: FastifyPluginAsync = async (fastify) => {
  fastify.get('/health', {
    schema: {
      description: 'Check if the service is running',
      tags: ['Health'],
      response: {
        200: {
          description: 'Service is healthy',
          type: 'object',
          properties: {
            status: {
              type: 'string',
              enum: ['healthy'],
              example: 'healthy',
              description: 'Health status of the service',
            },
            service: {
              type: 'string',
              example: '{{service.name}}',
              description: 'Name of the service',
            },
            port: {
              type: 'number',
              example: {{service.port}},
              description: 'Port the service is running on',
            },
            uptime: {
              type: 'number',
              example: 3600,
              description: 'Process uptime in seconds',
            },
            timestamp: {
              type: 'string',
              format: 'date-time',
              example: '2024-01-01T00:00:00.000Z',
              description: 'Timestamp of the health check',
            },
          },
        },
      },
    },
  }, async (request, reply) => {
    return {
      status: 'healthy',
      service: '{{service.name}}',
      port: {{service.port}},
      uptime: process.uptime(),
      timestamp: new Date().toISOString(),
    };
  });

  fastify.get('/ready', {
    schema: {
      description: 'Check if the service and its dependencies are ready',
      tags: ['Health'],
      response: {
        200: {
          description: 'Service and all dependencies are ready',
          type: 'object',
          properties: {
            status: {
              type: 'string',
              enum: ['ready'],
              example: 'ready',
              description: 'Readiness status',
            },
            checks: {
              type: 'object',
              description: 'Individual dependency health checks',
              properties: {
                {{#if service.features.database}}database: {
                  type: 'object',
                  properties: {
                    status: { type: 'string', enum: ['up', 'down'], description: 'Status of the dependency' },
                    responseTime: { type: 'number', description: 'Response time in milliseconds' },
                    message: { type: 'string', description: 'Optional error message if down' }
                  },
                  required: ['status', 'responseTime'],
                  description: 'Database connection status',
                },
                {{/if}}{{#if service.features.cache}}redis: {
                  type: 'object',
                  properties: {
                    status: { type: 'string', enum: ['up', 'down'], description: 'Status of the dependency' },
                    responseTime: { type: 'number', description: 'Response time in milliseconds' },
                    message: { type: 'string', description: 'Optional error message if down' }
                  },
                  required: ['status', 'responseTime'],
                  description: 'Redis connection status',
                },
                {{/if}}{{#if service.features.messageQueue}}nats: {
                  type: 'object',
                  properties: {
                    status: { type: 'string', enum: ['up', 'down'], description: 'Status of the dependency' },
                    responseTime: { type: 'number', description: 'Response time in milliseconds' },
                    message: { type: 'string', description: 'Optional error message if down' }
                  },
                  required: ['status', 'responseTime'],
                  description: 'NATS connection status',
                },
                {{/if}}
              },
            },
            service: {
              type: 'string',
              example: '{{service.name}}',
              description: 'Name of the service',
            },
            timestamp: {
              type: 'string',
              format: 'date-time',
              example: '2024-01-01T00:00:00.000Z',
              description: 'Timestamp of the readiness check',
            },
          },
        },
        503: {
          description: 'Service or dependencies are not ready',
          type: 'object',
          properties: {
            status: {
              type: 'string',
              enum: ['not ready'],
              example: 'not ready',
              description: 'Readiness status',
            },
            checks: {
              type: 'object',
              description: 'Individual dependency health checks',
              properties: {
                {{#if service.features.database}}database: {
                  type: 'object',
                  properties: {
                    status: { type: 'string', enum: ['up', 'down'] },
                    responseTime: { type: 'number' },
                    message: { type: 'string' }
                  },
                  required: ['status', 'responseTime']
                },
                {{/if}}{{#if service.features.cache}}redis: {
                  type: 'object',
                  properties: {
                    status: { type: 'string', enum: ['up', 'down'] },
                    responseTime: { type: 'number' },
                    message: { type: 'string' }
                  },
                  required: ['status', 'responseTime']
                },
                {{/if}}{{#if service.features.messageQueue}}nats: {
                  type: 'object',
                  properties: {
                    status: { type: 'string', enum: ['up', 'down'] },
                    responseTime: { type: 'number' },
                    message: { type: 'string' }
                  },
                  required: ['status', 'responseTime']
                },
                {{/if}}
              },
            },
            service: {
              type: 'string',
              example: '{{service.name}}',
            },
            timestamp: {
              type: 'string',
              format: 'date-time',
            },
          },
        },
      },
    },
  }, async (request, reply) => {
    const checks: Record<string, { status: string; responseTime: number; message?: string }> = {};

    {{#if service.features.database}}// Check database
    const dbStart = Date.now();
    try {
      await fastify.db.raw('SELECT 1');
      checks.database = {
        status: 'up',
        responseTime: Date.now() - dbStart,
      };
    } catch (error) {
      checks.database = {
        status: 'down',
        responseTime: Date.now() - dbStart,
        message: error instanceof Error ? error.message : 'Database connection failed',
      };
    }

    {{/if}}{{#if service.features.cache}}// Check Redis
    const redisStart = Date.now();
    try {
      await fastify.redis.ping();
      checks.redis = {
        status: 'up',
        responseTime: Date.now() - redisStart,
      };
    } catch (error) {
      checks.redis = {
        status: 'down',
        responseTime: Date.now() - redisStart,
        message: error instanceof Error ? error.message : 'Redis connection failed',
      };
    }

    {{/if}}{{#if service.features.messageQueue}}// Check NATS
    const natsStart = Date.now();
    try {
      const isConnected = fastify.nats.isClosed() === false;
      checks.nats = {
        status: isConnected ? 'up' : 'down',
        responseTime: Date.now() - natsStart,
        message: isConnected ? undefined : 'NATS connection closed',
      };
    } catch (error) {
      checks.nats = {
        status: 'down',
        responseTime: Date.now() - natsStart,
        message: error instanceof Error ? error.message : 'NATS connection failed',
      };
    }

    {{/if}}const allHealthy = Object.values(checks).every(c => c.status === 'up');
    const status = allHealthy ? 'ready' : 'not_ready';

    reply.code(allHealthy ? 200 : 503);
    return {
      status,
      checks,
      service: '{{service.name}}',
      timestamp: new Date().toISOString(),
    };
  });

  fastify.get('/metrics', {
    schema: {
      description: 'Get service metrics and resource usage',
      tags: ['Health'],
      response: {
        200: {
          description: 'Current service metrics',
          type: 'object',
          properties: {
            timestamp: { type: 'string', format: 'date-time' },
            uptime: { type: 'number', description: 'Process uptime in seconds' },
            memory: {
              type: 'object',
              properties: {
                rss: { type: 'number', description: 'Resident Set Size in bytes' },
                heapTotal: { type: 'number', description: 'Total heap size in bytes' },
                heapUsed: { type: 'number', description: 'Used heap size in bytes' },
                external: { type: 'number', description: 'External memory in bytes' },
              },
            },
            cpu: {
              type: 'object',
              properties: {
                user: { type: 'number', description: 'User CPU time in microseconds' },
                system: { type: 'number', description: 'System CPU time in microseconds' },
              },
            },
            eventLoop: {
              type: 'object',
              properties: {
                delay: { type: 'number', description: 'Event loop delay in milliseconds' },
              },
            },
          },
        },
      },
    },
  }, async (request, reply) => {
    const memUsage = process.memoryUsage();
    const cpuUsage = process.cpuUsage();

    // Measure event loop delay
    const start = Date.now();
    await new Promise(resolve => setImmediate(resolve));
    const eventLoopDelay = Date.now() - start;

    return {
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      memory: {
        rss: memUsage.rss,
        heapTotal: memUsage.heapTotal,
        heapUsed: memUsage.heapUsed,
        external: memUsage.external,
      },
      cpu: {
        user: cpuUsage.user,
        system: cpuUsage.system,
      },
      eventLoop: {
        delay: eventLoopDelay,
      },
    };
  });
};
