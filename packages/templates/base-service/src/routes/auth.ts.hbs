import { FastifyPluginAsync } from 'fastify';
import { Type, Static } from '@sinclair/typebox';
import bcrypt from 'bcrypt';
import crypto from 'crypto';
import { User, UserResponse, toUserResponse, RegisterRequest, LoginRequest } from '../models/index.js';
import { validatePassword, getPasswordRequirementsText } from '../utils/password-validator.js';
import { AuditLogService } from '../services/audit-log.service.js';
{{#if features.cache}}import { LoginAttemptService } from '../services/login-attempt.service.js';
{{/if}}{{#if features.messageQueue}}
import {
  publishUserRegistered,
  publishUserLoggedIn,
  publishUserLoggedOut,
  publishUserTokenRefreshed,
} from '../utils/events.js';
{{/if}}

// Constants
const SALT_ROUNDS = 10;

// TypeBox schemas for type-safe validation
const RegisterSchema = Type.Object({
  email: Type.String({ format: 'email', description: 'User email address' }),
  password: Type.String({ minLength: 8, description: 'User password (minimum 8 characters)' }),
  name: Type.String({ minLength: 2, description: 'User full name' }),
});

const LoginSchema = Type.Object({
  email: Type.String({ format: 'email', description: 'User email address' }),
  password: Type.String({ description: 'User password' }),
});

const RefreshTokenSchema = Type.Object({
  refreshToken: Type.String({ description: 'JWT refresh token' }),
});

const UserResponseSchema = Type.Object({
  id: Type.String({ description: 'User ID' }),
  email: Type.String({ format: 'email', description: 'User email' }),
  name: Type.String({ description: 'User name' }),
  createdAt: Type.String({ format: 'date-time', description: 'Account creation timestamp' }),
  updatedAt: Type.String({ format: 'date-time', description: 'Last update timestamp' }),
});

const AuthResponseSchema = Type.Object({
  accessToken: Type.String({ description: 'JWT access token (expires in 15 minutes)' }),
  refreshToken: Type.String({ description: 'JWT refresh token (expires in 7 days)' }),
  user: UserResponseSchema,
});

const ErrorResponseSchema = Type.Object({
  statusCode: Type.Integer({ description: 'HTTP status code' }),
  error: Type.String({ description: 'Error type' }),
  message: Type.String({ description: 'Error message' }),
});

// Helper functions
async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, SALT_ROUNDS);
}

async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

export const authRoutes: FastifyPluginAsync = async (fastify) => {
  // Initialize AuditLogService
  const auditLog = new AuditLogService(fastify);

  // POST /auth/register - Register a new user
  fastify.post('/auth/register', {
    {{#if features.cache}}config: {
      rateLimit: {
        max: 3,
        timeWindow: '1 hour',
      },
    },
    {{/if}}schema: {
      description: 'Register a new user account',
      tags: ['Authentication'],
      summary: 'Register new user',
      body: RegisterSchema,
      response: {
        201: {
          description: 'User successfully registered',
          content: {
            'application/json': {
              schema: AuthResponseSchema,
              example: {
                accessToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMjNlNDU2Ny1lODliLTEyZDMtYTQ1Ni00MjY2MTQxNzQwMDAiLCJlbWFpbCI6InVzZXJAZXhhbXBsZS5jb20iLCJpYXQiOjE3MDQwNjcyMDAsImV4cCI6MTcwNDA2ODEwMH0.example',
                refreshToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMjNlNDU2Ny1lODliLTEyZDMtYTQ1Ni00MjY2MTQxNzQwMDAiLCJ0eXBlIjoicmVmcmVzaCIsImlhdCI6MTcwNDA2NzIwMCwiZXhwIjoxNzA0NjcyMDAwfQ.example',
                user: {
                  id: '123e4567-e89b-12d3-a456-426614174000',
                  email: 'user@example.com',
                  name: 'John Doe',
                  createdAt: '2024-01-01T00:00:00.000Z',
                  updatedAt: '2024-01-01T00:00:00.000Z',
                },
              },
            },
          },
        },
        400: {
          description: 'Validation error or email already exists',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
              example: {
                statusCode: 400,
                error: 'Bad Request',
                message: 'Email already registered',
              },
            },
          },
        },
        500: {
          description: 'Internal server error',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
            },
          },
        },
      },
    },
  }, async (request, reply) => {
    const { email, password, name } = request.body as Static<typeof RegisterSchema>;
    const ip = (request.headers['x-forwarded-for'] as string) || request.ip;

    try {
      // Validate password strength
      const passwordValidation = validatePassword(password);
      if (!passwordValidation.valid) {
        await auditLog.logEvent('user.registration_failed', {
          email,
          reason: 'weak_password',
          errors: passwordValidation.errors,
        }, undefined, { ip, headers: request.headers });

        return reply.code(400).send({
          statusCode: 400,
          error: 'Bad Request',
          message: `Password does not meet requirements. ${passwordValidation.errors.join(' ')} ${getPasswordRequirementsText()}`,
        });
      }

      // Check if user already exists
      const existingUser = await fastify.db('users')
        .where({ email })
        .first();

      if (existingUser) {
        await auditLog.logEvent('user.registration_failed', {
          email,
          reason: 'email_exists',
        }, undefined, { ip, headers: request.headers });

        return reply.code(400).send({
          statusCode: 400,
          error: 'Bad Request',
          message: 'Email already registered. Please use a different email or try logging in.',
        });
      }

      // Hash password
      const passwordHash = await hashPassword(password);

      // Generate UUID for user
      const userId = crypto.randomUUID();

      // Create user in database
      await fastify.db('users').insert({
        id: userId,
        email,
        name,
        password_hash: passwordHash,
        created_at: new Date(),
        updated_at: new Date(),
      });

      // Fetch created user
      const user = await fastify.db('users')
        .where({ id: userId })
        .first() as User;

      {{#if service.features.cache}}
      // Generate JWT tokens using TokenService
      const { accessToken, refreshToken } = await fastify.tokenService.generateTokenPair(
        user.id,
        user.email
      );
      {{else}}
      // Generate JWT tokens (fallback without TokenService)
      const accessToken = fastify.jwt.sign(
        { id: user.id, email: user.email },
        { expiresIn: '15m' }
      );

      const refreshToken = fastify.jwt.sign(
        { id: user.id, email: user.email, type: 'refresh' },
        { expiresIn: '7d' }
      );
      {{/if}}

      fastify.log.info({ userId: user.id, email: user.email }, 'User registered successfully');

      // Log registration in audit log
      await auditLog.logRegistration(user.id, user.email, ip);

      {{#if features.messageQueue}}
      // Publish user registered event to NATS (fire-and-forget)
      publishUserRegistered(fastify.nats, user.id, user.email, user.name, fastify.log);
      {{/if}}

      // Track registration metric
      {{#if service.features.jwt}}if (fastify.authMetrics) {
        fastify.authMetrics.registrationTotal.inc();
      }
      {{/if}}

      reply.code(201);
      return {
        accessToken,
        refreshToken,
        user: toUserResponse(user),
      };
    } catch (error) {
      fastify.log.error({ error, email }, 'Registration failed');
      await auditLog.logEvent('user.registration_failed', {
        email,
        reason: 'internal_error',
        error: error instanceof Error ? error.message : 'Unknown error',
      }, undefined, { ip, headers: request.headers });
      return reply.code(500).send({
        statusCode: 500,
        error: 'Internal Server Error',
        message: 'Registration failed. Please try again later.',
      });
    }
  });

  // POST /auth/login - Login user
  fastify.post('/auth/login', {
    {{#if features.cache}}config: {
      rateLimit: {
        max: 5,
        timeWindow: '15 minutes',
      },
    },
    {{/if}}schema: {
      description: 'Authenticate user and receive JWT tokens',
      tags: ['Authentication'],
      summary: 'User login',
      body: LoginSchema,
      response: {
        200: {
          description: 'Login successful',
          content: {
            'application/json': {
              schema: AuthResponseSchema,
              example: {
                accessToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
                refreshToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
                user: {
                  id: '123e4567-e89b-12d3-a456-426614174000',
                  email: 'user@example.com',
                  name: 'John Doe',
                  createdAt: '2024-01-01T00:00:00.000Z',
                  updatedAt: '2024-01-01T00:00:00.000Z',
                },
              },
            },
          },
        },
        401: {
          description: 'Invalid credentials',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
              example: {
                statusCode: 401,
                error: 'Unauthorized',
                message: 'Invalid email or password',
              },
            },
          },
        },{{#if features.cache}}
        429: {
          description: 'Too many failed login attempts - Account temporarily locked',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
              example: {
                statusCode: 429,
                error: 'Too Many Requests',
                message: 'Account temporarily locked due to too many failed login attempts. Please try again in 30 minutes.',
              },
            },
          },
        },{{/if}}
        500: {
          description: 'Internal server error',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
            },
          },
        },
      },
    },
  }, async (request, reply) => {
    const { email, password } = request.body as Static<typeof LoginSchema>;
    {{#if features.cache}}const ip = (request.headers['x-forwarded-for'] as string) || request.ip;
    {{/if}}

    try {
      {{#if features.cache}}// Initialize LoginAttemptService
      const loginAttemptService = new LoginAttemptService(fastify, fastify.redis);

      // Check if account is locked
      const isLocked = await loginAttemptService.isAccountLocked(email);

      if (isLocked) {
        const timeRemaining = await loginAttemptService.getLockoutTimeRemaining(email);
        const minutesRemaining = Math.ceil(timeRemaining / 60);

        // Log account lockout
        await auditLog.logAccountLocked(email, ip);

        return reply.code(429).send({
          statusCode: 429,
          error: 'Too Many Requests',
          message: `Account temporarily locked due to too many failed login attempts. Please try again in ${minutesRemaining} minutes.`,
        });
      }

      {{/if}}// Find user by email
      const user = await fastify.db('users')
        .where({ email })
        .first() as User | undefined;

      if (!user) {
        {{#if features.cache}}// Record failed attempt
        await loginAttemptService.recordAttempt(email, false, ip);
        const remaining = await loginAttemptService.getRemainingAttempts(email);

        // Log failed login attempt
        await auditLog.logFailedLogin(email, 'user_not_found', ip);

        // Track failed login metric
        {{#if service.features.jwt}}if (fastify.authMetrics) {
          fastify.authMetrics.loginTotal.inc({ status: 'failure' });
        }
        {{/if}}

        if (remaining > 0) {
          return reply.code(401).send({
            statusCode: 401,
            error: 'Unauthorized',
            message: `Invalid email or password. ${remaining} attempts remaining before account lockout.`,
          });
        }
        {{/if}}
        // Log failed login attempt
        await auditLog.logFailedLogin(email, 'user_not_found', ip);

        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Invalid email or password. Please check your credentials and try again.',
        });
      }

      // Verify password
      const isPasswordValid = await verifyPassword(password, user.password_hash);

      if (!isPasswordValid) {
        {{#if features.cache}}// Record failed attempt
        await loginAttemptService.recordAttempt(email, false, ip);
        const remaining = await loginAttemptService.getRemainingAttempts(email);

        // Log failed login attempt
        await auditLog.logFailedLogin(email, 'invalid_password', ip);

        // Track failed login metric
        {{#if service.features.jwt}}if (fastify.authMetrics) {
          fastify.authMetrics.loginTotal.inc({ status: 'failure' });
        }
        {{/if}}

        if (remaining > 0) {
          return reply.code(401).send({
            statusCode: 401,
            error: 'Unauthorized',
            message: `Invalid email or password. ${remaining} attempts remaining before account lockout.`,
          });
        }
        {{/if}}
        // Log failed login attempt
        await auditLog.logFailedLogin(email, 'invalid_password', ip);

        // Track failed login metric
        {{#if service.features.jwt}}if (fastify.authMetrics) {
          fastify.authMetrics.loginTotal.inc({ status: 'failure' });
        }
        {{/if}}

        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Invalid email or password. Please check your credentials and try again.',
        });
      }

      {{#if features.cache}}// Record successful login and clear attempts
      await loginAttemptService.recordAttempt(email, true, ip);
      {{/if}}

      // Update last login timestamp
      await fastify.db('users')
        .where({ id: user.id })
        .update({ last_login_at: new Date() });

      {{#if service.features.cache}}
      // Generate JWT tokens using TokenService
      const { accessToken, refreshToken } = await fastify.tokenService.generateTokenPair(
        user.id,
        user.email
      );
      {{else}}
      // Generate JWT tokens (fallback without TokenService)
      const accessToken = fastify.jwt.sign(
        { id: user.id, email: user.email },
        { expiresIn: '15m' }
      );

      const refreshToken = fastify.jwt.sign(
        { id: user.id, email: user.email, type: 'refresh' },
        { expiresIn: '7d' }
      );
      {{/if}}

      fastify.log.info({ userId: user.id, email: user.email }, 'User logged in successfully');

      // Log successful login in audit log
      const userAgent = request.headers['user-agent'] as string;
      await auditLog.logLogin(user.id, user.email, ip, userAgent);

      // Track successful login metric
      {{#if service.features.jwt}}if (fastify.authMetrics) {
        fastify.authMetrics.loginTotal.inc({ status: 'success' });
      }
      {{/if}}

      {{#if features.messageQueue}}
      // Publish user logged in event to NATS (fire-and-forget)
      publishUserLoggedIn(fastify.nats, user.id, user.email, fastify.log, ip, userAgent);
      {{/if}}

      return {
        accessToken,
        refreshToken,
        user: toUserResponse(user),
      };
    } catch (error) {
      fastify.log.error({ error, email }, 'Login failed');
      const ip = (request.headers['x-forwarded-for'] as string) || request.ip;
      await auditLog.logEvent('user.login_failed', {
        email,
        reason: 'internal_error',
        error: error instanceof Error ? error.message : 'Unknown error',
      }, undefined, { ip, headers: request.headers });
      return reply.code(500).send({
        statusCode: 500,
        error: 'Internal Server Error',
        message: 'Login failed. Please try again later.',
      });
    }
  });

  // POST /auth/refresh - Refresh access token
  fastify.post('/auth/refresh', {
    schema: {
      description: 'Refresh access token using refresh token',
      tags: ['Authentication'],
      summary: 'Refresh access token',
      body: RefreshTokenSchema,
      response: {
        200: {
          description: 'Token refreshed successfully',
          content: {
            'application/json': {
              schema: Type.Object({
                accessToken: Type.String({ description: 'New JWT access token' }),
                refreshToken: Type.String({ description: 'New JWT refresh token' }),
              }),
              example: {
                accessToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
                refreshToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
              },
            },
          },
        },
        401: {
          description: 'Invalid or expired refresh token',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
              example: {
                statusCode: 401,
                error: 'Unauthorized',
                message: 'Invalid refresh token',
              },
            },
          },
        },
        500: {
          description: 'Internal server error',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
            },
          },
        },
      },
    },
  }, async (request, reply) => {
    const { refreshToken } = request.body as Static<typeof RefreshTokenSchema>;

    try {
      {{#if service.features.cache}}
      // Verify refresh token
      const decoded = fastify.jwt.verify(refreshToken) as { id: string; email: string; type?: string };

      // Check if token is a refresh token
      if (decoded.type !== 'refresh') {
        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Invalid token type. Please provide a valid refresh token.',
        });
      }

      // Use TokenService to refresh access token
      const newAccessToken = await fastify.tokenService.refreshAccessToken(
        refreshToken,
        decoded.email
      );

      // Generate new refresh token (token rotation for security)
      const newRefreshToken = await fastify.tokenService.generateRefreshToken(decoded.id);

      // Revoke old refresh token (prevent reuse)
      await fastify.tokenService.revokeToken(refreshToken);

      fastify.log.info({ userId: decoded.id }, 'Token refreshed successfully');

      // Log token refresh in audit log
      await auditLog.logTokenRefresh(decoded.id);

      // Track token refresh metric
      {{#if service.features.jwt}}if (fastify.authMetrics) {
        fastify.authMetrics.tokenRefreshTotal.inc();
      }
      {{/if}}
      {{else}}
      // Fallback without TokenService
      const decoded = fastify.jwt.verify(refreshToken) as { id: string; email: string; type?: string };

      // Check if token is a refresh token
      if (decoded.type !== 'refresh') {
        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Invalid token type. Please provide a valid refresh token.',
        });
      }

      // Generate new access token
      const newAccessToken = fastify.jwt.sign(
        { id: decoded.id, email: decoded.email },
        { expiresIn: '15m' }
      );

      // Generate new refresh token (token rotation for security)
      const newRefreshToken = fastify.jwt.sign(
        { id: decoded.id, email: decoded.email, type: 'refresh' },
        { expiresIn: '7d' }
      );

      fastify.log.info({ userId: decoded.id }, 'Token refreshed successfully');

      // Log token refresh in audit log
      await auditLog.logTokenRefresh(decoded.id);

      // Track token refresh metric
      {{#if service.features.jwt}}if (fastify.authMetrics) {
        fastify.authMetrics.tokenRefreshTotal.inc();
      }
      {{/if}}
      {{/if}}

      {{#if features.messageQueue}}
      // Publish token refreshed event to NATS (fire-and-forget)
      publishUserTokenRefreshed(fastify.nats, decoded.id, fastify.log);
      {{/if}}

      return {
        accessToken: newAccessToken,
        refreshToken: newRefreshToken,
      };
    } catch (error) {
      fastify.log.error({ error }, 'Token refresh failed');
      return reply.code(401).send({
        statusCode: 401,
        error: 'Unauthorized',
        message: 'Invalid or expired refresh token. Please log in again.',
      });
    }
  });

  // POST /auth/logout - Logout user
  fastify.post('/auth/logout', {
    schema: {
      description: 'Logout user and invalidate tokens',
      tags: ['Authentication'],
      summary: 'User logout',
      security: [{ bearerAuth: [] }],
      headers: Type.Object({
        authorization: Type.String({ description: 'Bearer token', pattern: '^Bearer .+' }),
      }),
      response: {
        200: {
          description: 'Logout successful',
          content: {
            'application/json': {
              schema: Type.Object({
                message: Type.String({ description: 'Success message' }),
              }),
              example: {
                message: 'Logout successful',
              },
            },
          },
        },
        401: {
          description: 'Unauthorized - Invalid or missing token',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
              example: {
                statusCode: 401,
                error: 'Unauthorized',
                message: 'Invalid or missing authorization token',
              },
            },
          },
        },
        500: {
          description: 'Internal server error',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
            },
          },
        },
      },
    },
  }, async (request, reply) => {
    try {
      // Extract token from Authorization header
      const authHeader = request.headers.authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Missing or invalid authorization header. Please provide a valid Bearer token.',
        });
      }

      const token = authHeader.substring(7); // Remove 'Bearer ' prefix

      // Verify token
      const decoded = fastify.jwt.verify(token) as { id: string; email: string };

      {{#if service.features.cache}}
      // Revoke token using TokenService
      await fastify.tokenService.revokeToken(token);
      {{/if}}

      fastify.log.info({ userId: decoded.id }, 'User logged out successfully');

      // Log logout in audit log
      const ip = (request.headers['x-forwarded-for'] as string) || request.ip;
      await auditLog.logLogout(decoded.id, ip);

      // Track logout metric
      {{#if service.features.jwt}}if (fastify.authMetrics) {
        fastify.authMetrics.logoutTotal.inc();
      }
      {{/if}}

      {{#if features.messageQueue}}
      // Publish user logged out event to NATS (fire-and-forget)
      publishUserLoggedOut(fastify.nats, decoded.id, fastify.log);
      {{/if}}

      return {
        message: 'Logout successful',
      };
    } catch (error) {
      fastify.log.error({ error }, 'Logout failed');
      return reply.code(401).send({
        statusCode: 401,
        error: 'Unauthorized',
        message: 'Invalid or expired token. Unable to logout.',
      });
    }
  });

  // POST /auth/verify - Token verification endpoint for service-to-service communication
  fastify.post('/auth/verify', {
    schema: {
      description: 'Verify JWT token validity (service-to-service endpoint)',
      tags: ['Authentication'],
      summary: 'Verify token',
      body: Type.Object({
        token: Type.String({ description: 'JWT access token to verify' }),
      }),
      response: {
        200: {
          description: 'Token is valid',
          content: {
            'application/json': {
              schema: Type.Object({
                valid: Type.Boolean({ example: true }),
                userId: Type.String({ format: 'uuid' }),
                email: Type.String({ format: 'email' }),
                tenantId: Type.String({ description: 'Tenant ID' }),
              }),
            },
          },
        },
        401: {
          description: 'Token is invalid or expired',
          content: {
            'application/json': {
              schema: Type.Object({
                valid: Type.Boolean({ example: false }),
                error: Type.String(),
              }),
            },
          },
        },
      },
    },
  }, async (request, reply) => {
    const { token } = request.body as { token: string };

    try {
      // Verify token signature and expiry
      const decoded = await fastify.jwt.verify(token) as any;

      {{#if service.features.cache}}
      // Check if token is blacklisted
      const isBlacklisted = await fastify.redis.get(`blacklist:${token}`);

      if (isBlacklisted) {
        return reply.code(401).send({
          valid: false,
          error: 'Token has been revoked'
        });
      }
      {{/if}}

      // Return token claims
      return {
        valid: true,
        userId: decoded.userId || decoded.id,
        email: decoded.email,
        tenantId: decoded.tenantId || 'default'
      };
    } catch (error) {
      fastify.log.warn({ error: error.message }, 'Token verification failed');
      return reply.code(401).send({
        valid: false,
        error: 'Invalid or expired token'
      });
    }
  });

  // GET /auth/me - Get current user profile
  fastify.get('/auth/me', {
    schema: {
      description: 'Get authenticated user profile',
      tags: ['Authentication'],
      summary: 'Get current user',
      security: [{ bearerAuth: [] }],
      headers: Type.Object({
        authorization: Type.String({ description: 'Bearer token', pattern: '^Bearer .+' }),
      }),
      response: {
        200: {
          description: 'User profile retrieved successfully',
          content: {
            'application/json': {
              schema: UserResponseSchema,
              example: {
                id: '123e4567-e89b-12d3-a456-426614174000',
                email: 'user@example.com',
                name: 'John Doe',
                createdAt: '2024-01-01T00:00:00.000Z',
                updatedAt: '2024-01-01T00:00:00.000Z',
              },
            },
          },
        },
        401: {
          description: 'Unauthorized - Invalid or missing token',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
              example: {
                statusCode: 401,
                error: 'Unauthorized',
                message: 'Invalid or missing authorization token',
              },
            },
          },
        },
        404: {
          description: 'User not found',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
              example: {
                statusCode: 404,
                error: 'Not Found',
                message: 'User not found',
              },
            },
          },
        },
        500: {
          description: 'Internal server error',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
            },
          },
        },
      },
    },
  }, async (request, reply) => {
    try {
      // Extract token from Authorization header
      const authHeader = request.headers.authorization;

      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Missing or invalid authorization header. Please provide a Bearer token.',
        });
      }

      const token = authHeader.substring(7); // Remove 'Bearer ' prefix

      {{#if service.features.cache}}
      // Verify JWT token using TokenService (checks blacklist)
      const decoded = await fastify.tokenService.verifyToken(token) as { userId: string; email: string };

      // Fetch user from database
      const user = await fastify.db('users')
        .where({ id: decoded.userId })
        .first() as User | undefined;
      {{else}}
      // Verify JWT token (fallback without TokenService)
      const decoded = fastify.jwt.verify<{ id: string; email: string }>(token);

      // Fetch user from database
      const user = await fastify.db('users')
        .where({ id: decoded.id })
        .first() as User | undefined;
      {{/if}}

      if (!user) {
        return reply.code(404).send({
          statusCode: 404,
          error: 'Not Found',
          message: 'User account not found. The account may have been deleted.',
        });
      }

      // Return user profile (password_hash is excluded by toUserResponse)
      return toUserResponse(user);
    } catch (error) {
      fastify.log.error({ error }, 'Failed to get user profile');

      if (error instanceof Error && error.name === 'JsonWebTokenError') {
        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Invalid authorization token. Please log in again.',
        });
      }

      if (error instanceof Error && error.name === 'TokenExpiredError') {
        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Token has expired. Please refresh your token or log in again.',
        });
      }

      return reply.code(500).send({
        statusCode: 500,
        error: 'Internal Server Error',
        message: 'Failed to retrieve user profile. Please try again later.',
      });
    }
  });
};
