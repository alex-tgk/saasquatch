import { FastifyPluginAsync } from 'fastify';
import { Type, Static } from '@sinclair/typebox';
import bcrypt from 'bcrypt';
import crypto from 'crypto';
{{#if features.messageQueue}}
import {
  publishUserRegistered,
  publishUserLoggedIn,
  publishUserLoggedOut,
  publishUserTokenRefreshed,
} from '../utils/events.js';
{{/if}}

// Constants
const SALT_ROUNDS = 10;
const ACCESS_TOKEN_EXPIRY = '15m';
const REFRESH_TOKEN_EXPIRY = '7d';
const TOKEN_BLACKLIST_PREFIX = 'blacklist:';

// TypeBox schemas for type-safe validation
const RegisterSchema = Type.Object({
  email: Type.String({ format: 'email', description: 'User email address' }),
  password: Type.String({ minLength: 8, description: 'User password (minimum 8 characters)' }),
  name: Type.String({ minLength: 2, description: 'User full name' }),
});

const LoginSchema = Type.Object({
  email: Type.String({ format: 'email', description: 'User email address' }),
  password: Type.String({ description: 'User password' }),
});

const RefreshTokenSchema = Type.Object({
  refreshToken: Type.String({ description: 'JWT refresh token' }),
});

const UserResponseSchema = Type.Object({
  id: Type.String({ description: 'User ID' }),
  email: Type.String({ format: 'email', description: 'User email' }),
  name: Type.String({ description: 'User name' }),
  createdAt: Type.String({ format: 'date-time', description: 'Account creation timestamp' }),
  updatedAt: Type.String({ format: 'date-time', description: 'Last update timestamp' }),
});

const AuthResponseSchema = Type.Object({
  accessToken: Type.String({ description: 'JWT access token (expires in 15 minutes)' }),
  refreshToken: Type.String({ description: 'JWT refresh token (expires in 7 days)' }),
  user: UserResponseSchema,
});

const ErrorResponseSchema = Type.Object({
  statusCode: Type.Integer({ description: 'HTTP status code' }),
  error: Type.String({ description: 'Error type' }),
  message: Type.String({ description: 'Error message' }),
});

// Helper functions
interface User {
  id: string;
  email: string;
  name: string;
  password_hash: string;
  created_at: Date;
  updated_at: Date;
  last_login_at?: Date;
}

interface UserResponse {
  id: string;
  email: string;
  name: string;
  createdAt: string;
  updatedAt: string;
}

function mapUserToResponse(user: User): UserResponse {
  return {
    id: user.id,
    email: user.email,
    name: user.name,
    createdAt: user.created_at.toISOString(),
    updatedAt: user.updated_at.toISOString(),
  };
}

async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, SALT_ROUNDS);
}

async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

export const authRoutes: FastifyPluginAsync = async (fastify) => {
  // POST /auth/register - Register a new user
  fastify.post('/auth/register', {
    schema: {
      description: 'Register a new user account',
      tags: ['Authentication'],
      summary: 'Register new user',
      body: RegisterSchema,
      response: {
        201: {
          description: 'User successfully registered',
          content: {
            'application/json': {
              schema: AuthResponseSchema,
              example: {
                accessToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMjNlNDU2Ny1lODliLTEyZDMtYTQ1Ni00MjY2MTQxNzQwMDAiLCJlbWFpbCI6InVzZXJAZXhhbXBsZS5jb20iLCJpYXQiOjE3MDQwNjcyMDAsImV4cCI6MTcwNDA2ODEwMH0.example',
                refreshToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIxMjNlNDU2Ny1lODliLTEyZDMtYTQ1Ni00MjY2MTQxNzQwMDAiLCJ0eXBlIjoicmVmcmVzaCIsImlhdCI6MTcwNDA2NzIwMCwiZXhwIjoxNzA0NjcyMDAwfQ.example',
                user: {
                  id: '123e4567-e89b-12d3-a456-426614174000',
                  email: 'user@example.com',
                  name: 'John Doe',
                  createdAt: '2024-01-01T00:00:00.000Z',
                  updatedAt: '2024-01-01T00:00:00.000Z',
                },
              },
            },
          },
        },
        400: {
          description: 'Validation error or email already exists',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
              example: {
                statusCode: 400,
                error: 'Bad Request',
                message: 'Email already registered',
              },
            },
          },
        },
        500: {
          description: 'Internal server error',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
            },
          },
        },
      },
    },
  }, async (request, reply) => {
    const { email, password, name } = request.body as Static<typeof RegisterSchema>;

    try {
      // Check if user already exists
      const existingUser = await fastify.db('users')
        .where({ email })
        .first();

      if (existingUser) {
        return reply.code(400).send({
          statusCode: 400,
          error: 'Bad Request',
          message: 'Email already registered. Please use a different email or try logging in.',
        });
      }

      // Hash password
      const passwordHash = await hashPassword(password);

      // Generate UUID for user
      const userId = crypto.randomUUID();

      // Create user in database
      await fastify.db('users').insert({
        id: userId,
        email,
        name,
        password_hash: passwordHash,
        created_at: new Date(),
        updated_at: new Date(),
      });

      // Fetch created user
      const user = await fastify.db('users')
        .where({ id: userId })
        .first() as User;

      // Generate JWT tokens
      const accessToken = fastify.jwt.sign(
        { id: user.id, email: user.email },
        { expiresIn: ACCESS_TOKEN_EXPIRY }
      );

      const refreshToken = fastify.jwt.sign(
        { id: user.id, email: user.email, type: 'refresh' },
        { expiresIn: REFRESH_TOKEN_EXPIRY }
      );

      fastify.log.info({ userId: user.id, email: user.email }, 'User registered successfully');

      {{#if features.messageQueue}}
      // Publish user registered event to NATS (fire-and-forget)
      publishUserRegistered(fastify.nats, user.id, user.email, user.name, fastify.log);
      {{/if}}

      reply.code(201);
      return {
        accessToken,
        refreshToken,
        user: mapUserToResponse(user),
      };
    } catch (error) {
      fastify.log.error({ error, email }, 'Registration failed');
      return reply.code(500).send({
        statusCode: 500,
        error: 'Internal Server Error',
        message: 'Registration failed. Please try again later.',
      });
    }
  });

  // POST /auth/login - Login user
  fastify.post('/auth/login', {
    schema: {
      description: 'Authenticate user and receive JWT tokens',
      tags: ['Authentication'],
      summary: 'User login',
      body: LoginSchema,
      response: {
        200: {
          description: 'Login successful',
          content: {
            'application/json': {
              schema: AuthResponseSchema,
              example: {
                accessToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
                refreshToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
                user: {
                  id: '123e4567-e89b-12d3-a456-426614174000',
                  email: 'user@example.com',
                  name: 'John Doe',
                  createdAt: '2024-01-01T00:00:00.000Z',
                  updatedAt: '2024-01-01T00:00:00.000Z',
                },
              },
            },
          },
        },
        401: {
          description: 'Invalid credentials',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
              example: {
                statusCode: 401,
                error: 'Unauthorized',
                message: 'Invalid email or password',
              },
            },
          },
        },
        500: {
          description: 'Internal server error',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
            },
          },
        },
      },
    },
  }, async (request, reply) => {
    const { email, password } = request.body as Static<typeof LoginSchema>;

    try {
      // Find user by email
      const user = await fastify.db('users')
        .where({ email })
        .first() as User | undefined;

      if (!user) {
        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Invalid email or password. Please check your credentials and try again.',
        });
      }

      // Verify password
      const isPasswordValid = await verifyPassword(password, user.password_hash);

      if (!isPasswordValid) {
        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Invalid email or password. Please check your credentials and try again.',
        });
      }

      // Update last login timestamp
      await fastify.db('users')
        .where({ id: user.id })
        .update({ last_login_at: new Date() });

      // Generate JWT tokens
      const accessToken = fastify.jwt.sign(
        { id: user.id, email: user.email },
        { expiresIn: ACCESS_TOKEN_EXPIRY }
      );

      const refreshToken = fastify.jwt.sign(
        { id: user.id, email: user.email, type: 'refresh' },
        { expiresIn: REFRESH_TOKEN_EXPIRY }
      );

      fastify.log.info({ userId: user.id, email: user.email }, 'User logged in successfully');

      {{#if features.messageQueue}}
      // Publish user logged in event to NATS (fire-and-forget)
      // Extract IP and user agent if available
      const ip = request.headers['x-forwarded-for'] as string || request.ip;
      const userAgent = request.headers['user-agent'];
      publishUserLoggedIn(fastify.nats, user.id, user.email, fastify.log, ip, userAgent);
      {{/if}}

      return {
        accessToken,
        refreshToken,
        user: mapUserToResponse(user),
      };
    } catch (error) {
      fastify.log.error({ error, email }, 'Login failed');
      return reply.code(500).send({
        statusCode: 500,
        error: 'Internal Server Error',
        message: 'Login failed. Please try again later.',
      });
    }
  });

  // POST /auth/refresh - Refresh access token
  fastify.post('/auth/refresh', {
    schema: {
      description: 'Refresh access token using refresh token',
      tags: ['Authentication'],
      summary: 'Refresh access token',
      body: RefreshTokenSchema,
      response: {
        200: {
          description: 'Token refreshed successfully',
          content: {
            'application/json': {
              schema: Type.Object({
                accessToken: Type.String({ description: 'New JWT access token' }),
                refreshToken: Type.String({ description: 'New JWT refresh token' }),
              }),
              example: {
                accessToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
                refreshToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
              },
            },
          },
        },
        401: {
          description: 'Invalid or expired refresh token',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
              example: {
                statusCode: 401,
                error: 'Unauthorized',
                message: 'Invalid refresh token',
              },
            },
          },
        },
        500: {
          description: 'Internal server error',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
            },
          },
        },
      },
    },
  }, async (request, reply) => {
    const { refreshToken } = request.body as Static<typeof RefreshTokenSchema>;

    try {
      // Verify refresh token
      const decoded = fastify.jwt.verify(refreshToken) as { id: string; email: string; type?: string };

      // Check if token is a refresh token
      if (decoded.type !== 'refresh') {
        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Invalid token type. Please provide a valid refresh token.',
        });
      }

      // Check if refresh token is blacklisted (logged out)
      {{#if features.cache}}
      const isBlacklisted = await fastify.redis.get(`${TOKEN_BLACKLIST_PREFIX}${refreshToken}`);
      if (isBlacklisted) {
        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Token has been invalidated. Please log in again.',
        });
      }
      {{/if}}

      // Generate new access token
      const newAccessToken = fastify.jwt.sign(
        { id: decoded.id, email: decoded.email },
        { expiresIn: ACCESS_TOKEN_EXPIRY }
      );

      // Generate new refresh token (token rotation for security)
      const newRefreshToken = fastify.jwt.sign(
        { id: decoded.id, email: decoded.email, type: 'refresh' },
        { expiresIn: REFRESH_TOKEN_EXPIRY }
      );

      {{#if features.cache}}
      // Blacklist old refresh token (prevent reuse)
      await fastify.redis.set(
        `${TOKEN_BLACKLIST_PREFIX}${refreshToken}`,
        '1',
        'EX',
        7 * 24 * 60 * 60 // 7 days
      );
      {{/if}}

      fastify.log.info({ userId: decoded.id }, 'Token refreshed successfully');

      {{#if features.messageQueue}}
      // Publish token refreshed event to NATS (fire-and-forget)
      publishUserTokenRefreshed(fastify.nats, decoded.id, fastify.log);
      {{/if}}

      return {
        accessToken: newAccessToken,
        refreshToken: newRefreshToken,
      };
    } catch (error) {
      fastify.log.error({ error }, 'Token refresh failed');
      return reply.code(401).send({
        statusCode: 401,
        error: 'Unauthorized',
        message: 'Invalid or expired refresh token. Please log in again.',
      });
    }
  });

  // POST /auth/logout - Logout user
  fastify.post('/auth/logout', {
    schema: {
      description: 'Logout user and invalidate tokens',
      tags: ['Authentication'],
      summary: 'User logout',
      security: [{ bearerAuth: [] }],
      headers: Type.Object({
        authorization: Type.String({ description: 'Bearer token', pattern: '^Bearer .+' }),
      }),
      response: {
        200: {
          description: 'Logout successful',
          content: {
            'application/json': {
              schema: Type.Object({
                message: Type.String({ description: 'Success message' }),
              }),
              example: {
                message: 'Logout successful',
              },
            },
          },
        },
        401: {
          description: 'Unauthorized - Invalid or missing token',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
              example: {
                statusCode: 401,
                error: 'Unauthorized',
                message: 'Invalid or missing authorization token',
              },
            },
          },
        },
        500: {
          description: 'Internal server error',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
            },
          },
        },
      },
    },
  }, async (request, reply) => {
    try {
      // Extract token from Authorization header
      const authHeader = request.headers.authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Missing or invalid authorization header. Please provide a valid Bearer token.',
        });
      }

      const token = authHeader.substring(7); // Remove 'Bearer ' prefix

      // Verify token
      const decoded = fastify.jwt.verify(token) as { id: string; email: string };

      {{#if features.cache}}
      // Add token to Redis blacklist
      // Token expiry is 15 minutes, so blacklist for 15 minutes
      await fastify.redis.set(
        `${TOKEN_BLACKLIST_PREFIX}${token}`,
        '1',
        'EX',
        15 * 60 // 15 minutes in seconds
      );
      {{/if}}

      fastify.log.info({ userId: decoded.id }, 'User logged out successfully');

      {{#if features.messageQueue}}
      // Publish user logged out event to NATS (fire-and-forget)
      publishUserLoggedOut(fastify.nats, decoded.id, fastify.log);
      {{/if}}

      return {
        message: 'Logout successful',
      };
    } catch (error) {
      fastify.log.error({ error }, 'Logout failed');
      return reply.code(401).send({
        statusCode: 401,
        error: 'Unauthorized',
        message: 'Invalid or expired token. Unable to logout.',
      });
    }
  });

  // GET /auth/me - Get current user profile
  fastify.get('/auth/me', {
    schema: {
      description: 'Get authenticated user profile',
      tags: ['Authentication'],
      summary: 'Get current user',
      security: [{ bearerAuth: [] }],
      headers: Type.Object({
        authorization: Type.String({ description: 'Bearer token', pattern: '^Bearer .+' }),
      }),
      response: {
        200: {
          description: 'User profile retrieved successfully',
          content: {
            'application/json': {
              schema: UserResponseSchema,
              example: {
                id: '123e4567-e89b-12d3-a456-426614174000',
                email: 'user@example.com',
                name: 'John Doe',
                createdAt: '2024-01-01T00:00:00.000Z',
                updatedAt: '2024-01-01T00:00:00.000Z',
              },
            },
          },
        },
        401: {
          description: 'Unauthorized - Invalid or missing token',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
              example: {
                statusCode: 401,
                error: 'Unauthorized',
                message: 'Invalid or missing authorization token',
              },
            },
          },
        },
        404: {
          description: 'User not found',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
              example: {
                statusCode: 404,
                error: 'Not Found',
                message: 'User not found',
              },
            },
          },
        },
        500: {
          description: 'Internal server error',
          content: {
            'application/json': {
              schema: ErrorResponseSchema,
            },
          },
        },
      },
    },
  }, async (request, reply) => {
    try {
      // Extract token from Authorization header
      const authHeader = request.headers.authorization;

      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Missing or invalid authorization header. Please provide a Bearer token.',
        });
      }

      const token = authHeader.substring(7); // Remove 'Bearer ' prefix

      // Verify JWT token
      const decoded = fastify.jwt.verify<{ id: string; email: string }>(token);

      {{#if features.cache}}
      // Check if token is blacklisted (logged out)
      const isBlacklisted = await fastify.redis.get(`${TOKEN_BLACKLIST_PREFIX}${token}`);
      if (isBlacklisted) {
        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Token has been revoked. Please log in again.',
        });
      }
      {{/if}}

      // Fetch user from database
      const user = await fastify.db('users')
        .where({ id: decoded.id })
        .first() as User | undefined;

      if (!user) {
        return reply.code(404).send({
          statusCode: 404,
          error: 'Not Found',
          message: 'User account not found. The account may have been deleted.',
        });
      }

      // Return user profile (password_hash is excluded by mapUserToResponse)
      return mapUserToResponse(user);
    } catch (error) {
      fastify.log.error({ error }, 'Failed to get user profile');

      if (error instanceof Error && error.name === 'JsonWebTokenError') {
        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Invalid authorization token. Please log in again.',
        });
      }

      if (error instanceof Error && error.name === 'TokenExpiredError') {
        return reply.code(401).send({
          statusCode: 401,
          error: 'Unauthorized',
          message: 'Token has expired. Please refresh your token or log in again.',
        });
      }

      return reply.code(500).send({
        statusCode: 500,
        error: 'Internal Server Error',
        message: 'Failed to retrieve user profile. Please try again later.',
      });
    }
  });
};
