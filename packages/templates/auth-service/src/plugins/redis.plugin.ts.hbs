import fp from 'fastify-plugin';
import Redis from 'ioredis';

declare module 'fastify' {
  interface FastifyInstance {
    redis: Redis;
  }
}

export interface RedisService {
  setUserSession(userId: string, sessionData: any, expiresIn: number): Promise<void>;
  getUserSession(userId: string): Promise<any>;
  deleteUserSession(userId: string): Promise<void>;
  setRefreshToken(userId: string, token: string, expiresIn: number): Promise<void>;
  getRefreshToken(userId: string): Promise<string | null>;
  deleteRefreshToken(userId: string): Promise<void>;
}

async function redisPlugin(fastify: any) {
  const redis = new Redis({
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379', 10),
    password: process.env.REDIS_PASSWORD,
    db: parseInt(process.env.REDIS_DB || '0', 10),
    retryStrategy: (times: number) => {
      const delay = Math.min(times * 50, 2000);
      return delay;
    },
    maxRetriesPerRequest: 3,
    enableReadyCheck: true,
    lazyConnect: false,
  });

  // Connection event handlers
  redis.on('connect', () => {
    fastify.log.info('Redis connection established');
  });

  redis.on('ready', () => {
    fastify.log.info('Redis ready to accept commands');
  });

  redis.on('error', (error) => {
    fastify.log.error({ err: error }, 'Redis connection error');
  });

  redis.on('close', () => {
    fastify.log.warn('Redis connection closed');
  });

  redis.on('reconnecting', () => {
    fastify.log.info('Redis reconnecting');
  });

  // Wait for Redis to be ready
  try {
    await redis.ping();
    fastify.log.info('Redis ping successful');
  } catch (error) {
    fastify.log.error({ err: error }, 'Redis ping failed');
    throw error;
  }

  // Redis service for auth-specific caching operations
  const redisService: RedisService = {
    async setUserSession(userId: string, sessionData: any, expiresIn: number) {
      const key = `session:${userId}`;
      await redis.set(key, JSON.stringify(sessionData), 'EX', expiresIn);
      fastify.log.debug({ userId, expiresIn }, 'User session stored');
    },

    async getUserSession(userId: string) {
      const key = `session:${userId}`;
      const data = await redis.get(key);
      if (!data) return null;

      try {
        return JSON.parse(data);
      } catch (error) {
        fastify.log.error({ err: error, userId }, 'Failed to parse session data');
        return null;
      }
    },

    async deleteUserSession(userId: string) {
      const key = `session:${userId}`;
      await redis.del(key);
      fastify.log.debug({ userId }, 'User session deleted');
    },

    async setRefreshToken(userId: string, token: string, expiresIn: number) {
      const key = `refresh_token:${userId}`;
      await redis.set(key, token, 'EX', expiresIn);
      fastify.log.debug({ userId, expiresIn }, 'Refresh token stored');
    },

    async getRefreshToken(userId: string) {
      const key = `refresh_token:${userId}`;
      return await redis.get(key);
    },

    async deleteRefreshToken(userId: string) {
      const key = `refresh_token:${userId}`;
      await redis.del(key);
      fastify.log.debug({ userId }, 'Refresh token deleted');
    },
  };

  // Decorate Fastify instance
  fastify.decorate('redis', redis);
  fastify.decorate('redisService', redisService);

  // Cleanup on shutdown
  fastify.addHook('onClose', async () => {
    fastify.log.info('Closing Redis connection');
    await redis.quit();
  });

  fastify.log.info('Redis plugin registered');
}

export default fp(redisPlugin, {
  name: 'redis',
});

export { redisPlugin };
