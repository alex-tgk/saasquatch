import { describe, it, expect, beforeEach, afterEach, beforeAll, afterAll } from '@jest/globals';
import Knex from 'knex';
import { UserRepository } from '../../src/repositories/user.repository.js';

/**
 * Comprehensive unit tests for UserRepository
 *
 * These tests run against a real PostgreSQL database to ensure
 * repository methods work correctly with actual database operations.
 *
 * Test database setup:
 * - Creates a test tenant schema before each test
 * - Drops the schema after each test for isolation
 * - Tests multi-tenancy by verifying schema-based isolation
 */
describe('UserRepository', () => {
  let db: Knex.Knex;
  let userRepo: UserRepository;
  const testTenantId = 'test-tenant-123';
  const testTenantSchema = `tenant_${testTenantId}`;

  beforeAll(async () => {
    // Create database connection
    db = Knex({
      client: 'pg',
      connection: {
        host: process.env.DB_HOST || 'localhost',
        port: parseInt(process.env.DB_PORT || '5432'),
        user: process.env.DB_USER || 'postgres',
        password: process.env.DB_PASSWORD || 'postgres',
        database: process.env.DB_NAME || 'test_db',
      },
    });

    // Test database connectivity
    try {
      await db.raw('SELECT 1');
    } catch (error) {
      console.error('Failed to connect to test database:', error);
      throw error;
    }
  });

  afterAll(async () => {
    await db.destroy();
  });

  beforeEach(async () => {
    // Create tenant schema and tables
    await db.raw(`CREATE SCHEMA IF NOT EXISTS ${testTenantSchema}`);
    await db.raw(`SET search_path TO ${testTenantSchema}`);
    await db.raw(`
      CREATE TABLE IF NOT EXISTS users (
        id UUID PRIMARY KEY,
        email VARCHAR(255) UNIQUE NOT NULL,
        name VARCHAR(255) NOT NULL,
        avatar_url VARCHAR(500),
        metadata JSONB DEFAULT '{}'::jsonb,
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW(),
        deleted_at TIMESTAMP
      )
    `);

    userRepo = new UserRepository(db);
  });

  afterEach(async () => {
    // Clean up test schema
    await db.raw(`DROP SCHEMA IF EXISTS ${testTenantSchema} CASCADE`);
  });

  describe('create', () => {
    it('should create a new user with all required fields', async () => {
      const userData = {
        email: 'test@example.com',
        name: 'Test User',
      };

      const user = await userRepo.create(userData, testTenantId);

      expect(user).toBeDefined();
      expect(user.id).toBeDefined();
      expect(typeof user.id).toBe('string');
      expect(user.email).toBe(userData.email);
      expect(user.name).toBe(userData.name);
      expect(user.avatar_url).toBeNull();
      expect(user.metadata).toEqual({});
      expect(user.created_at).toBeInstanceOf(Date);
      expect(user.updated_at).toBeInstanceOf(Date);
      expect(user.deleted_at).toBeNull();
    });

    it('should create user with avatar URL when provided', async () => {
      const userData = {
        email: 'test@example.com',
        name: 'Test User',
        avatarUrl: 'https://example.com/avatar.jpg',
      };

      const user = await userRepo.create(userData, testTenantId);

      expect(user.avatar_url).toBe(userData.avatarUrl);
    });

    it('should generate unique IDs for each user', async () => {
      const user1 = await userRepo.create({ email: 'user1@example.com', name: 'User 1' }, testTenantId);
      const user2 = await userRepo.create({ email: 'user2@example.com', name: 'User 2' }, testTenantId);

      expect(user1.id).not.toBe(user2.id);
    });

    it('should fail when creating user with duplicate email', async () => {
      const userData = {
        email: 'duplicate@example.com',
        name: 'Test User',
      };

      await userRepo.create(userData, testTenantId);

      await expect(userRepo.create(userData, testTenantId)).rejects.toThrow();
    });

    it('should set created_at and updated_at to the same time on creation', async () => {
      const user = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);

      expect(user.created_at.getTime()).toBe(user.updated_at.getTime());
    });
  });

  describe('findAll', () => {
    it('should return all non-deleted users', async () => {
      await userRepo.create({ email: 'user1@example.com', name: 'User 1' }, testTenantId);
      await userRepo.create({ email: 'user2@example.com', name: 'User 2' }, testTenantId);

      const users = await userRepo.findAll(testTenantId);

      expect(users).toHaveLength(2);
    });

    it('should return users ordered by created_at descending', async () => {
      const user1 = await userRepo.create({ email: 'user1@example.com', name: 'User 1' }, testTenantId);
      // Small delay to ensure different timestamps
      await new Promise(resolve => setTimeout(resolve, 10));
      const user2 = await userRepo.create({ email: 'user2@example.com', name: 'User 2' }, testTenantId);

      const users = await userRepo.findAll(testTenantId);

      expect(users[0].id).toBe(user2.id); // Most recent first
      expect(users[1].id).toBe(user1.id);
    });

    it('should return empty array when no users exist', async () => {
      const users = await userRepo.findAll(testTenantId);
      expect(users).toEqual([]);
    });

    it('should exclude soft-deleted users', async () => {
      const user = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);
      await userRepo.delete(user.id, testTenantId);

      const users = await userRepo.findAll(testTenantId);

      expect(users).toHaveLength(0);
    });

    it('should support pagination with limit', async () => {
      await userRepo.create({ email: 'user1@example.com', name: 'User 1' }, testTenantId);
      await userRepo.create({ email: 'user2@example.com', name: 'User 2' }, testTenantId);
      await userRepo.create({ email: 'user3@example.com', name: 'User 3' }, testTenantId);

      const users = await userRepo.findAll(testTenantId, 2, 0);

      expect(users).toHaveLength(2);
    });

    it('should support pagination with offset', async () => {
      const user1 = await userRepo.create({ email: 'user1@example.com', name: 'User 1' }, testTenantId);
      await new Promise(resolve => setTimeout(resolve, 10));
      await userRepo.create({ email: 'user2@example.com', name: 'User 2' }, testTenantId);
      await new Promise(resolve => setTimeout(resolve, 10));
      await userRepo.create({ email: 'user3@example.com', name: 'User 3' }, testTenantId);

      const users = await userRepo.findAll(testTenantId, 10, 2);

      expect(users).toHaveLength(1);
      expect(users[0].id).toBe(user1.id); // Oldest user (skipped first 2)
    });
  });

  describe('count', () => {
    it('should return correct count of users', async () => {
      await userRepo.create({ email: 'user1@example.com', name: 'User 1' }, testTenantId);
      await userRepo.create({ email: 'user2@example.com', name: 'User 2' }, testTenantId);

      const count = await userRepo.count(testTenantId);

      expect(count).toBe(2);
    });

    it('should return 0 when no users exist', async () => {
      const count = await userRepo.count(testTenantId);
      expect(count).toBe(0);
    });

    it('should exclude soft-deleted users from count', async () => {
      const user = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);
      await userRepo.create({ email: 'test2@example.com', name: 'Test User 2' }, testTenantId);
      await userRepo.delete(user.id, testTenantId);

      const count = await userRepo.count(testTenantId);

      expect(count).toBe(1);
    });
  });

  describe('findById', () => {
    it('should find user by ID', async () => {
      const created = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);

      const found = await userRepo.findById(created.id, testTenantId);

      expect(found).toBeDefined();
      expect(found?.id).toBe(created.id);
      expect(found?.email).toBe(created.email);
      expect(found?.name).toBe(created.name);
    });

    it('should return null when user not found', async () => {
      const found = await userRepo.findById('550e8400-e29b-41d4-a716-446655440000', testTenantId);
      expect(found).toBeNull();
    });

    it('should return null for soft-deleted user', async () => {
      const created = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);
      await userRepo.delete(created.id, testTenantId);

      const found = await userRepo.findById(created.id, testTenantId);

      expect(found).toBeNull();
    });
  });

  describe('findByEmail', () => {
    it('should find user by email', async () => {
      const created = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);

      const found = await userRepo.findByEmail('test@example.com', testTenantId);

      expect(found).toBeDefined();
      expect(found?.id).toBe(created.id);
      expect(found?.email).toBe(created.email);
    });

    it('should return null when email not found', async () => {
      const found = await userRepo.findByEmail('nonexistent@example.com', testTenantId);
      expect(found).toBeNull();
    });

    it('should return null for soft-deleted user', async () => {
      const created = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);
      await userRepo.delete(created.id, testTenantId);

      const found = await userRepo.findByEmail('test@example.com', testTenantId);

      expect(found).toBeNull();
    });

    it('should be case-sensitive', async () => {
      await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);

      const found = await userRepo.findByEmail('TEST@EXAMPLE.COM', testTenantId);

      expect(found).toBeNull();
    });
  });

  describe('update', () => {
    it('should update user name', async () => {
      const created = await userRepo.create({ email: 'test@example.com', name: 'Old Name' }, testTenantId);

      const updated = await userRepo.update(created.id, { name: 'New Name' }, testTenantId);

      expect(updated.name).toBe('New Name');
      expect(updated.email).toBe(created.email);
      expect(updated.id).toBe(created.id);
    });

    it('should update avatar URL', async () => {
      const created = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);

      const updated = await userRepo.update(created.id, { avatarUrl: 'https://example.com/new-avatar.jpg' }, testTenantId);

      expect(updated.avatar_url).toBe('https://example.com/new-avatar.jpg');
    });

    it('should update both name and avatar URL', async () => {
      const created = await userRepo.create({ email: 'test@example.com', name: 'Old Name' }, testTenantId);

      const updated = await userRepo.update(
        created.id,
        { name: 'New Name', avatarUrl: 'https://example.com/avatar.jpg' },
        testTenantId
      );

      expect(updated.name).toBe('New Name');
      expect(updated.avatar_url).toBe('https://example.com/avatar.jpg');
    });

    it('should update updated_at timestamp', async () => {
      const created = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);
      await new Promise(resolve => setTimeout(resolve, 10));

      const updated = await userRepo.update(created.id, { name: 'New Name' }, testTenantId);

      expect(updated.updated_at.getTime()).toBeGreaterThan(created.updated_at.getTime());
    });

    it('should not modify created_at timestamp', async () => {
      const created = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);
      const originalCreatedAt = created.created_at.getTime();

      const updated = await userRepo.update(created.id, { name: 'New Name' }, testTenantId);

      expect(updated.created_at.getTime()).toBe(originalCreatedAt);
    });

    it('should not update email field', async () => {
      const created = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);

      // Email should not be updated even if passed (interface doesn't allow it)
      const updated = await userRepo.update(created.id, { name: 'New Name' }, testTenantId);

      expect(updated.email).toBe(created.email);
    });
  });

  describe('delete (soft delete)', () => {
    it('should soft delete user by setting deleted_at', async () => {
      const created = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);

      await userRepo.delete(created.id, testTenantId);

      // User should not be findable by normal queries
      const found = await userRepo.findById(created.id, testTenantId);
      expect(found).toBeNull();

      // But should exist in database with deleted_at set
      const deletedUser = await db('users').where({ id: created.id }).first();
      expect(deletedUser).toBeDefined();
      expect(deletedUser.deleted_at).toBeDefined();
      expect(deletedUser.deleted_at).toBeInstanceOf(Date);
    });

    it('should update updated_at on soft delete', async () => {
      const created = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);
      await new Promise(resolve => setTimeout(resolve, 10));

      await userRepo.delete(created.id, testTenantId);

      const deletedUser = await db('users').where({ id: created.id }).first();
      expect(deletedUser.updated_at.getTime()).toBeGreaterThan(created.updated_at.getTime());
    });

    it('should not throw error when deleting already deleted user', async () => {
      const created = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);
      await userRepo.delete(created.id, testTenantId);

      // Should not throw (though it won't update anything since where clause filters deleted)
      await expect(userRepo.delete(created.id, testTenantId)).resolves.not.toThrow();
    });

    it('should not affect other users', async () => {
      const user1 = await userRepo.create({ email: 'user1@example.com', name: 'User 1' }, testTenantId);
      const user2 = await userRepo.create({ email: 'user2@example.com', name: 'User 2' }, testTenantId);

      await userRepo.delete(user1.id, testTenantId);

      const remainingUsers = await userRepo.findAll(testTenantId);
      expect(remainingUsers).toHaveLength(1);
      expect(remainingUsers[0].id).toBe(user2.id);
    });
  });

  describe('hardDelete', () => {
    it('should permanently remove user from database', async () => {
      const created = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);

      await userRepo.hardDelete(created.id, testTenantId);

      // User should not exist at all
      const found = await db('users').where({ id: created.id }).first();
      expect(found).toBeUndefined();
    });

    it('should allow creating user with same email after hard delete', async () => {
      const created = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);
      await userRepo.hardDelete(created.id, testTenantId);

      // Should not throw unique constraint error
      const newUser = await userRepo.create({ email: 'test@example.com', name: 'Test User' }, testTenantId);

      expect(newUser.id).not.toBe(created.id);
      expect(newUser.email).toBe('test@example.com');
    });
  });

  describe('Multi-tenancy isolation', () => {
    const tenant2Id = 'test-tenant-456';
    const tenant2Schema = `tenant_${tenant2Id}`;

    beforeEach(async () => {
      // Create second tenant schema
      await db.raw(`CREATE SCHEMA IF NOT EXISTS ${tenant2Schema}`);
      await db.raw(`SET search_path TO ${tenant2Schema}`);
      await db.raw(`
        CREATE TABLE IF NOT EXISTS users (
          id UUID PRIMARY KEY,
          email VARCHAR(255) UNIQUE NOT NULL,
          name VARCHAR(255) NOT NULL,
          avatar_url VARCHAR(500),
          metadata JSONB DEFAULT '{}'::jsonb,
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW(),
          deleted_at TIMESTAMP
        )
      `);
    });

    afterEach(async () => {
      await db.raw(`DROP SCHEMA IF EXISTS ${tenant2Schema} CASCADE`);
    });

    it('should isolate data between tenants', async () => {
      // Create user in tenant 1
      await db.raw(`SET search_path TO ${testTenantSchema}`);
      const tenant1User = await userRepo.create({ email: 'tenant1@example.com', name: 'Tenant 1 User' }, testTenantId);

      // Create user in tenant 2
      await db.raw(`SET search_path TO ${tenant2Schema}`);
      const tenant2User = await userRepo.create({ email: 'tenant2@example.com', name: 'Tenant 2 User' }, tenant2Id);

      // Verify tenant 1 users
      await db.raw(`SET search_path TO ${testTenantSchema}`);
      const tenant1Users = await userRepo.findAll(testTenantId);
      expect(tenant1Users).toHaveLength(1);
      expect(tenant1Users[0].id).toBe(tenant1User.id);

      // Verify tenant 2 users
      await db.raw(`SET search_path TO ${tenant2Schema}`);
      const tenant2Users = await userRepo.findAll(tenant2Id);
      expect(tenant2Users).toHaveLength(1);
      expect(tenant2Users[0].id).toBe(tenant2User.id);
    });

    it('should allow same email in different tenants', async () => {
      const email = 'shared@example.com';

      // Create user in tenant 1
      await db.raw(`SET search_path TO ${testTenantSchema}`);
      await userRepo.create({ email, name: 'Tenant 1 User' }, testTenantId);

      // Should be able to create user with same email in tenant 2
      await db.raw(`SET search_path TO ${tenant2Schema}`);
      const tenant2User = await userRepo.create({ email, name: 'Tenant 2 User' }, tenant2Id);

      expect(tenant2User.email).toBe(email);
    });
  });
});
