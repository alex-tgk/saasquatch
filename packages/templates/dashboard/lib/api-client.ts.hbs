import { getServiceByName } from './service-config'

export type ServiceControlAction = 'start' | 'stop' | 'restart' | 'status'

export interface ServiceControlResponse {
  status: 'ok' | 'error'
  message: string
  code?: string
  result?: {
    service: string
    action: ServiceControlAction
    success: boolean
    output?: string
    startedAt: string
    finishedAt: string
  }
  details?: string
}

export interface ApiError {
  message: string
  statusCode: number
  details?: any
}

export class ApiClient {
  private baseUrl: string

  constructor(baseUrl?: string) {
    this.baseUrl = baseUrl || ''
  }

  private async request<T>(
    endpoint: string,
    options?: RequestInit
  ): Promise<T> {
    const url = this.baseUrl + endpoint

    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          ...options?.headers,
        },
      })

      if (!response.ok) {
        const error: ApiError = {
          message: `HTTP ${response.status}: ${response.statusText}`,
          statusCode: response.status,
        }

        try {
          const errorData = await response.json()
          error.details = errorData
        } catch {
          // Ignore JSON parse errors
        }

        throw error
      }

      // Handle no-content responses
      if (response.status === 204) {
        return {} as T
      }

      return await response.json()
    } catch (error) {
      if (error instanceof TypeError && error.message.includes('fetch')) {
        throw {
          message: 'Network error: Unable to connect to service',
          statusCode: 0,
          details: error,
        } as ApiError
      }
      throw error
    }
  }

  async get<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: 'GET' })
  }

  async post<T>(endpoint: string, data?: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'POST',
      body: data ? JSON.stringify(data) : undefined,
    })
  }

  async put<T>(endpoint: string, data?: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'PUT',
      body: data ? JSON.stringify(data) : undefined,
    })
  }

  async delete<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: 'DELETE' })
  }

  async patch<T>(endpoint: string, data?: any): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'PATCH',
      body: data ? JSON.stringify(data) : undefined,
    })
  }
}

// Service-specific clients
export function createServiceClient(serviceName: string): ApiClient {
  const service = getServiceByName(serviceName)
  if (!service) {
    throw new Error(`Unknown service: ${serviceName}`)
  }
  return new ApiClient(service.url)
}

// Dashboard API client (for dashboard's own API routes)
export const dashboardApi = new ApiClient('/api')

// Health check helper - uses dashboard API proxy to avoid CORS
export async function checkServiceHealth(serviceName: string) {
  try {
    const response = await dashboardApi.get<{
      status: string
      timestamp: string
      services: Array<{
        service: string
        status: string
        port?: number
        uptime?: number
        timestamp?: string
        error?: string
      }>
    }>('/health')

    const serviceData = response.services.find(s => s.service === serviceName)
    if (!serviceData) {
      throw new Error(`Service ${serviceName} not found in health response`)
    }

    return {
      status: serviceData.status,
      port: serviceData.port,
      uptime: serviceData.uptime || 0,
      timestamp: serviceData.timestamp || new Date().toISOString(),
      error: serviceData.error,
    }
  } catch (error) {
    return {
      status: 'offline',
      uptime: 0,
      timestamp: new Date().toISOString(),
      error: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}

// Ready check helper - uses dashboard API proxy to avoid CORS
export async function checkServiceReadiness(serviceName: string) {
  try {
    // Use the service-specific ready endpoint through the API proxy
    const service = getServiceByName(serviceName)
    if (!service) {
      throw new Error(`Unknown service: ${serviceName}`)
    }

    const response = await fetch(`/api/health`)
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`)
    }

    const data = await response.json()
    const serviceData = data.services.find((s: any) => s.service === serviceName)

    if (!serviceData) {
      throw new Error(`Service ${serviceName} not found`)
    }

    // Fetch ready endpoint through direct service call (requires CORS to be enabled)
    // For now, derive readiness from health check
    return {
      status: serviceData.status === 'healthy' ? 'ready' : 'not_ready',
      checks: {},
    }
  } catch (error) {
    return {
      status: 'not_ready',
      checks: {},
      error: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}

export async function controlServiceAction(serviceName: string, action: ServiceControlAction) {
  return dashboardApi.post<ServiceControlResponse>(`/services/${serviceName}/control`, { action })
}

// Helper for streaming responses (Server-Sent Events)
export async function* streamLogs(serviceName: string) {
  const service = getServiceByName(serviceName)
  if (!service) {
    throw new Error(`Unknown service: ${serviceName}`)
  }

  const response = await fetch(`/api/logs?service=${serviceName}`)
  if (!response.ok || !response.body) {
    throw new Error(`Failed to stream logs from ${serviceName}`)
  }

  const reader = response.body.getReader()
  const decoder = new TextDecoder()

  try {
    while (true) {
      const { done, value } = await reader.read()
      if (done) break

      const chunk = decoder.decode(value)
      const lines = chunk.split('\n')

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6)
          try {
            yield JSON.parse(data)
          } catch {
            // Skip invalid JSON
          }
        }
      }
    }
  } finally {
    reader.releaseLock()
  }
}
